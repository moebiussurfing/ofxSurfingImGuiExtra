#include <dear_widgets.h>

//#include <chrono>
//#include <algorithm>

#ifdef DEAR_WIDGETS_TESSELATION
//#include <vector>
#include <map>
#endif

namespace ImWidgets {
	//////////////////////////////////////////////////////////////////////////
	// Data
	//////////////////////////////////////////////////////////////////////////
#define ImSqrt3 1.7320508075688772935274463415059f

static const float DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f; // COPY PASTED FROM imgui_widgets.cpp
static const float DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f; // COPY PASTED FROM imgui_widgets.cpp

	static float s_CIE_1931_2deg_min = 360.0f;
	static float s_CIE_1931_2deg_max = 830.0f;
#define s_CIE_1931_2deg_samplesCount 471
	static float s_CIE_1931_2deg_X[] = { 0.000129900000f,0.000145847000f,0.000163802100f,0.000184003700f,0.000206690200f,0.000232100000f,0.000260728000f,0.000293075000f,0.000329388000f,0.000369914000f,0.000414900000f,0.000464158700f,0.000518986000f,0.000581854000f,0.000655234700f,0.000741600000f,0.000845029600f,0.000964526800f,0.001094949000f,0.001231154000f,0.001368000000f,0.001502050000f,0.001642328000f,0.001802382000f,0.001995757000f,0.002236000000f,0.002535385000f,0.002892603000f,0.003300829000f,0.003753236000f,0.004243000000f,0.004762389000f,0.005330048000f,0.005978712000f,0.006741117000f,0.007650000000f,0.008751373000f,0.010028880000f,0.011421700000f,0.012869010000f,0.014310000000f,0.015704430000f,0.017147440000f,0.018781220000f,0.020748010000f,0.023190000000f,0.026207360000f,0.029782480000f,0.033880920000f,0.038468240000f,0.043510000000f,0.048995600000f,0.055022600000f,0.061718800000f,0.069212000000f,0.077630000000f,0.086958110000f,0.097176720000f,0.108406300000f,0.120767200000f,0.134380000000f,0.149358200000f,0.165395700000f,0.181983100000f,0.198611000000f,0.214770000000f,0.230186800000f,0.244879700000f,0.258777300000f,0.271807900000f,0.283900000000f,0.294943800000f,0.304896500000f,0.313787300000f,0.321645400000f,0.328500000000f,0.334351300000f,0.339210100000f,0.343121300000f,0.346129600000f,0.348280000000f,0.349599900000f,0.350147400000f,0.350013000000f,0.349287000000f,0.348060000000f,0.346373300000f,0.344262400000f,0.341808800000f,0.339094100000f,0.336200000000f,0.333197700000f,0.330041100000f,0.326635700000f,0.322886800000f,0.318700000000f,0.314025100000f,0.308884000000f,0.303290400000f,0.297257900000f,0.290800000000f,0.283970100000f,0.276721400000f,0.268917800000f,0.260422700000f,0.251100000000f,0.240847500000f,0.229851200000f,0.218407200000f,0.206811500000f,0.195360000000f,0.184213600000f,0.173327300000f,0.162688100000f,0.152283300000f,0.142100000000f,0.132178600000f,0.122569600000f,0.113275200000f,0.104297900000f,0.095640000000f,0.087299550000f,0.079308040000f,0.071717760000f,0.064580990000f,0.057950010000f,0.051862110000f,0.046281520000f,0.041150880000f,0.036412830000f,0.032010000000f,0.027917200000f,0.024144400000f,0.020687000000f,0.017540400000f,0.014700000000f,0.012161790000f,0.009919960000f,0.007967240000f,0.006296346000f,0.004900000000f,0.003777173000f,0.002945320000f,0.002424880000f,0.002236293000f,0.002400000000f,0.002925520000f,0.003836560000f,0.005174840000f,0.006982080000f,0.009300000000f,0.012149490000f,0.015535880000f,0.019477520000f,0.023992770000f,0.029100000000f,0.034814850000f,0.041120160000f,0.047985040000f,0.055378610000f,0.063270000000f,0.071635010000f,0.080462240000f,0.089739960000f,0.099456450000f,0.109600000000f,0.120167400000f,0.131114500000f,0.142367900000f,0.153854200000f,0.165500000000f,0.177257100000f,0.189140000000f,0.201169400000f,0.213365800000f,0.225749900000f,0.238320900000f,0.251066800000f,0.263992200000f,0.277101700000f,0.290400000000f,0.303891200000f,0.317572600000f,0.331438400000f,0.345482800000f,0.359700000000f,0.374083900000f,0.388639600000f,0.403378400000f,0.418311500000f,0.433449900000f,0.448795300000f,0.464336000000f,0.480064000000f,0.495971300000f,0.512050100000f,0.528295900000f,0.544691600000f,0.561209400000f,0.577821500000f,0.594500000000f,0.611220900000f,0.627975800000f,0.644760200000f,0.661569700000f,0.678400000000f,0.695239200000f,0.712058600000f,0.728828400000f,0.745518800000f,0.762100000000f,0.778543200000f,0.794825600000f,0.810926400000f,0.826824800000f,0.842500000000f,0.857932500000f,0.873081600000f,0.887894400000f,0.902318100000f,0.916300000000f,0.929799500000f,0.942798400000f,0.955277600000f,0.967217900000f,0.978600000000f,0.989385600000f,0.999548800000f,1.009089200000f,1.018006400000f,1.026300000000f,1.033982700000f,1.040986000000f,1.047188000000f,1.052466700000f,1.056700000000f,1.059794400000f,1.061799200000f,1.062806800000f,1.062909600000f,1.062200000000f,1.060735200000f,1.058443600000f,1.055224400000f,1.050976800000f,1.045600000000f,1.039036900000f,1.031360800000f,1.022666200000f,1.013047700000f,1.002600000000f,0.991367500000f,0.979331400000f,0.966491600000f,0.952847900000f,0.938400000000f,0.923194000000f,0.907244000000f,0.890502000000f,0.872920000000f,0.854449900000f,0.835084000000f,0.814946000000f,0.794186000000f,0.772954000000f,0.751400000000f,0.729583600000f,0.707588800000f,0.685602200000f,0.663810400000f,0.642400000000f,0.621514900000f,0.601113800000f,0.581105200000f,0.561397700000f,0.541900000000f,0.522599500000f,0.503546400000f,0.484743600000f,0.466193900000f,0.447900000000f,0.429861300000f,0.412098000000f,0.394644000000f,0.377533300000f,0.360800000000f,0.344456300000f,0.328516800000f,0.313019200000f,0.298001100000f,0.283500000000f,0.269544800000f,0.256118400000f,0.243189600000f,0.230727200000f,0.218700000000f,0.207097100000f,0.195923200000f,0.185170800000f,0.174832300000f,0.164900000000f,0.155366700000f,0.146230000000f,0.137490000000f,0.129146700000f,0.121200000000f,0.113639700000f,0.106465000000f,0.099690440000f,0.093330610000f,0.087400000000f,0.081900960000f,0.076804280000f,0.072077120000f,0.067686640000f,0.063600000000f,0.059806850000f,0.056282160000f,0.052971040000f,0.049818610000f,0.046770000000f,0.043784050000f,0.040875360000f,0.038072640000f,0.035404610000f,0.032900000000f,0.030564190000f,0.028380560000f,0.026344840000f,0.024452750000f,0.022700000000f,0.021084290000f,0.019599880000f,0.018237320000f,0.016987170000f,0.015840000000f,0.014790640000f,0.013831320000f,0.012948680000f,0.012129200000f,0.011359160000f,0.010629350000f,0.009938846000f,0.009288422000f,0.008678854000f,0.008110916000f,0.007582388000f,0.007088746000f,0.006627313000f,0.006195408000f,0.005790346000f,0.005409826000f,0.005052583000f,0.004717512000f,0.004403507000f,0.004109457000f,0.003833913000f,0.003575748000f,0.003334342000f,0.003109075000f,0.002899327000f,0.002704348000f,0.002523020000f,0.002354168000f,0.002196616000f,0.002049190000f,0.001910960000f,0.001781438000f,0.001660110000f,0.001546459000f,0.001439971000f,0.001340042000f,0.001246275000f,0.001158471000f,0.001076430000f,0.000999949300f,0.000928735800f,0.000862433200f,0.000800750300f,0.000743396000f,0.000690078600f,0.000640515600f,0.000594502100f,0.000551864600f,0.000512429000f,0.000476021300f,0.000442453600f,0.000411511700f,0.000382981400f,0.000356649100f,0.000332301100f,0.000309758600f,0.000288887100f,0.000269539400f,0.000251568200f,0.000234826100f,0.000219171000f,0.000204525800f,0.000190840500f,0.000178065400f,0.000166150500f,0.000155023600f,0.000144621900f,0.000134909800f,0.000125852000f,0.000117413000f,0.000109551500f,0.000102224500f,0.000095394450f,0.000089023900f,0.000083075270f,0.000077512690f,0.000072313040f,0.000067457780f,0.000062928440f,0.000058706520f,0.000054770280f,0.000051099180f,0.000047676540f,0.000044485670f,0.000041509940f,0.000038733240f,0.000036142030f,0.000033723520f,0.000031464870f,0.000029353260f,0.000027375730f,0.000025524330f,0.000023793760f,0.000022178700f,0.000020673830f,0.000019272260f,0.000017966400f,0.000016749910f,0.000015616480f,0.000014559770f,0.000013573870f,0.000012654360f,0.000011797230f,0.000010998440f,0.000010253980f,0.000009559646f,0.000008912044f,0.000008308358f,0.000007745769f,0.000007221456f,0.000006732475f,0.000006276423f,0.000005851304f,0.000005455118f,0.000005085868f,0.000004741466f,0.000004420236f,0.000004120783f,0.000003841716f,0.000003581652f,0.000003339127f,0.000003112949f,0.000002902121f,0.000002705645f,0.000002522525f,0.000002351726f,0.000002192415f,0.000002043902f,0.000001905497f,0.000001776509f,0.000001656215f,0.000001544022f,0.000001439440f,0.000001341977f,0.000001251141f };
	static float s_CIE_1931_2deg_Y[] = { 0.000003917000f,0.000004393581f,0.000004929604f,0.000005532136f,0.000006208245f,0.000006965000f,0.000007813219f,0.000008767336f,0.000009839844f,0.000011043230f,0.000012390000f,0.000013886410f,0.000015557280f,0.000017442960f,0.000019583750f,0.000022020000f,0.000024839650f,0.000028041260f,0.000031531040f,0.000035215210f,0.000039000000f,0.000042826400f,0.000046914600f,0.000051589600f,0.000057176400f,0.000064000000f,0.000072344210f,0.000082212240f,0.000093508160f,0.000106136100f,0.000120000000f,0.000134984000f,0.000151492000f,0.000170208000f,0.000191816000f,0.000217000000f,0.000246906700f,0.000281240000f,0.000318520000f,0.000357266700f,0.000396000000f,0.000433714700f,0.000473024000f,0.000517876000f,0.000572218700f,0.000640000000f,0.000724560000f,0.000825500000f,0.000941160000f,0.001069880000f,0.001210000000f,0.001362091000f,0.001530752000f,0.001720368000f,0.001935323000f,0.002180000000f,0.002454800000f,0.002764000000f,0.003117800000f,0.003526400000f,0.004000000000f,0.004546240000f,0.005159320000f,0.005829280000f,0.006546160000f,0.007300000000f,0.008086507000f,0.008908720000f,0.009767680000f,0.010664430000f,0.011600000000f,0.012573170000f,0.013582720000f,0.014629680000f,0.015715090000f,0.016840000000f,0.018007360000f,0.019214480000f,0.020453920000f,0.021718240000f,0.023000000000f,0.024294610000f,0.025610240000f,0.026958570000f,0.028351250000f,0.029800000000f,0.031310830000f,0.032883680000f,0.034521120000f,0.036225710000f,0.038000000000f,0.039846670000f,0.041768000000f,0.043766000000f,0.045842670000f,0.048000000000f,0.050243680000f,0.052573040000f,0.054980560000f,0.057458720000f,0.060000000000f,0.062601970000f,0.065277520000f,0.068042080000f,0.070911090000f,0.073900000000f,0.077016000000f,0.080266400000f,0.083666800000f,0.087232800000f,0.090980000000f,0.094917550000f,0.099045840000f,0.103367400000f,0.107884600000f,0.112600000000f,0.117532000000f,0.122674400000f,0.127992800000f,0.133452800000f,0.139020000000f,0.144676400000f,0.150469300000f,0.156461900000f,0.162717700000f,0.169300000000f,0.176243100000f,0.183558100000f,0.191273500000f,0.199418000000f,0.208020000000f,0.217119900000f,0.226734500000f,0.236857100000f,0.247481200000f,0.258600000000f,0.270184900000f,0.282293900000f,0.295050500000f,0.308578000000f,0.323000000000f,0.338402100000f,0.354685800000f,0.371698600000f,0.389287500000f,0.407300000000f,0.425629900000f,0.444309600000f,0.463394400000f,0.482939500000f,0.503000000000f,0.523569300000f,0.544512000000f,0.565690000000f,0.586965300000f,0.608200000000f,0.629345600000f,0.650306800000f,0.670875200000f,0.690842400000f,0.710000000000f,0.728185200000f,0.745463600000f,0.761969400000f,0.777836800000f,0.793200000000f,0.808110400000f,0.822496200000f,0.836306800000f,0.849491600000f,0.862000000000f,0.873810800000f,0.884962400000f,0.895493600000f,0.905443200000f,0.914850100000f,0.923734800000f,0.932092400000f,0.939922600000f,0.947225200000f,0.954000000000f,0.960256100000f,0.966007400000f,0.971260600000f,0.976022500000f,0.980300000000f,0.984092400000f,0.987418200000f,0.990312800000f,0.992811600000f,0.994950100000f,0.996710800000f,0.998098300000f,0.999112000000f,0.999748200000f,1.000000000000f,0.999856700000f,0.999304600000f,0.998325500000f,0.996898700000f,0.995000000000f,0.992600500000f,0.989742600000f,0.986444400000f,0.982724100000f,0.978600000000f,0.974083700000f,0.969171200000f,0.963856800000f,0.958134900000f,0.952000000000f,0.945450400000f,0.938499200000f,0.931162800000f,0.923457600000f,0.915400000000f,0.907006400000f,0.898277200000f,0.889204800000f,0.879781600000f,0.870000000000f,0.859861300000f,0.849392000000f,0.838622000000f,0.827581300000f,0.816300000000f,0.804794700000f,0.793082000000f,0.781192000000f,0.769154700000f,0.757000000000f,0.744754100000f,0.732422400000f,0.720003600000f,0.707496500000f,0.694900000000f,0.682219200000f,0.669471600000f,0.656674400000f,0.643844800000f,0.631000000000f,0.618155500000f,0.605314400000f,0.592475600000f,0.579637900000f,0.566800000000f,0.553961100000f,0.541137200000f,0.528352800000f,0.515632300000f,0.503000000000f,0.490468800000f,0.478030400000f,0.465677600000f,0.453403200000f,0.441200000000f,0.429080000000f,0.417036000000f,0.405032000000f,0.393032000000f,0.381000000000f,0.368918400000f,0.356827200000f,0.344776800000f,0.332817600000f,0.321000000000f,0.309338100000f,0.297850400000f,0.286593600000f,0.275624500000f,0.265000000000f,0.254763200000f,0.244889600000f,0.235334400000f,0.226052800000f,0.217000000000f,0.208161600000f,0.199548800000f,0.191155200000f,0.182974400000f,0.175000000000f,0.167223500000f,0.159646400000f,0.152277600000f,0.145125900000f,0.138200000000f,0.131500300000f,0.125024800000f,0.118779200000f,0.112769100000f,0.107000000000f,0.101476200000f,0.096188640000f,0.091122960000f,0.086264850000f,0.081600000000f,0.077120640000f,0.072825520000f,0.068710080000f,0.064769760000f,0.061000000000f,0.057396210000f,0.053955040000f,0.050673760000f,0.047549650000f,0.044580000000f,0.041758720000f,0.039084960000f,0.036563840000f,0.034200480000f,0.032000000000f,0.029962610000f,0.028076640000f,0.026329360000f,0.024708050000f,0.023200000000f,0.021800770000f,0.020501120000f,0.019281080000f,0.018120690000f,0.017000000000f,0.015903790000f,0.014837180000f,0.013810680000f,0.012834780000f,0.011920000000f,0.011068310000f,0.010273390000f,0.009533311000f,0.008846157000f,0.008210000000f,0.007623781000f,0.007085424000f,0.006591476000f,0.006138485000f,0.005723000000f,0.005343059000f,0.004995796000f,0.004676404000f,0.004380075000f,0.004102000000f,0.003838453000f,0.003589099000f,0.003354219000f,0.003134093000f,0.002929000000f,0.002738139000f,0.002559876000f,0.002393244000f,0.002237275000f,0.002091000000f,0.001953587000f,0.001824580000f,0.001703580000f,0.001590187000f,0.001484000000f,0.001384496000f,0.001291268000f,0.001204092000f,0.001122744000f,0.001047000000f,0.000976589600f,0.000911108800f,0.000850133200f,0.000793238400f,0.000740000000f,0.000690082700f,0.000643310000f,0.000599496000f,0.000558454700f,0.000520000000f,0.000483913600f,0.000450052800f,0.000418345200f,0.000388718400f,0.000361100000f,0.000335383500f,0.000311440400f,0.000289165600f,0.000268453900f,0.000249200000f,0.000231301900f,0.000214685600f,0.000199288400f,0.000185047500f,0.000171900000f,0.000159778100f,0.000148604400f,0.000138301600f,0.000128792500f,0.000120000000f,0.000111859500f,0.000104322400f,0.000097335600f,0.000090845870f,0.000084800000f,0.000079146670f,0.000073858000f,0.000068916000f,0.000064302670f,0.000060000000f,0.000055981870f,0.000052225600f,0.000048718400f,0.000045447470f,0.000042400000f,0.000039561040f,0.000036915120f,0.000034448680f,0.000032148160f,0.000030000000f,0.000027991250f,0.000026113560f,0.000024360240f,0.000022724610f,0.000021200000f,0.000019778550f,0.000018452850f,0.000017216870f,0.000016064590f,0.000014990000f,0.000013987280f,0.000013051550f,0.000012178180f,0.000011362540f,0.000010600000f,0.000009885877f,0.000009217304f,0.000008592362f,0.000008009133f,0.000007465700f,0.000006959567f,0.000006487995f,0.000006048699f,0.000005639396f,0.000005257800f,0.000004901771f,0.000004569720f,0.000004260194f,0.000003971739f,0.000003702900f,0.000003452163f,0.000003218302f,0.000003000300f,0.000002797139f,0.000002607800f,0.000002431220f,0.000002266531f,0.000002113013f,0.000001969943f,0.000001836600f,0.000001712230f,0.000001596228f,0.000001488090f,0.000001387314f,0.000001293400f,0.000001205820f,0.000001124143f,0.000001048009f,0.000000977058f,0.000000910930f,0.000000849251f,0.000000791721f,0.000000738090f,0.000000688110f,0.000000641530f,0.000000598090f,0.000000557575f,0.000000519808f,0.000000484612f,0.000000451810f };
	static float s_CIE_1931_2deg_Z[] = { 0.000606100000f,0.000680879200f,0.000765145600f,0.000860012400f,0.000966592800f,0.001086000000f,0.001220586000f,0.001372729000f,0.001543579000f,0.001734286000f,0.001946000000f,0.002177777000f,0.002435809000f,0.002731953000f,0.003078064000f,0.003486000000f,0.003975227000f,0.004540880000f,0.005158320000f,0.005802907000f,0.006450001000f,0.007083216000f,0.007745488000f,0.008501152000f,0.009414544000f,0.010549990000f,0.011965800000f,0.013655870000f,0.015588050000f,0.017730150000f,0.020050010000f,0.022511360000f,0.025202880000f,0.028279720000f,0.031897040000f,0.036210000000f,0.041437710000f,0.047503720000f,0.054119880000f,0.060998030000f,0.067850010000f,0.074486320000f,0.081361560000f,0.089153640000f,0.098540480000f,0.110200000000f,0.124613300000f,0.141701700000f,0.161303500000f,0.183256800000f,0.207400000000f,0.233692100000f,0.262611400000f,0.294774600000f,0.330798500000f,0.371300000000f,0.416209100000f,0.465464200000f,0.519694800000f,0.579530300000f,0.645600000000f,0.718483800000f,0.796713300000f,0.877845900000f,0.959439000000f,1.039050100000f,1.115367300000f,1.188497100000f,1.258123300000f,1.323929600000f,1.385600000000f,1.442635200000f,1.494803500000f,1.542190300000f,1.584880700000f,1.622960000000f,1.656404800000f,1.685295900000f,1.709874500000f,1.730382100000f,1.747060000000f,1.760044600000f,1.769623300000f,1.776263700000f,1.780433400000f,1.782600000000f,1.782968200000f,1.781699800000f,1.779198200000f,1.775867100000f,1.772110000000f,1.768258900000f,1.764039000000f,1.758943800000f,1.752466300000f,1.744100000000f,1.733559500000f,1.720858100000f,1.705936900000f,1.688737200000f,1.669200000000f,1.647528700000f,1.623412700000f,1.596022300000f,1.564528000000f,1.528100000000f,1.486111400000f,1.439521500000f,1.389879900000f,1.338736200000f,1.287640000000f,1.237422300000f,1.187824300000f,1.138761100000f,1.090148000000f,1.041900000000f,0.994197600000f,0.947347300000f,0.901453100000f,0.856619300000f,0.812950100000f,0.770517300000f,0.729444800000f,0.689913600000f,0.652104900000f,0.616200000000f,0.582328600000f,0.550416200000f,0.520337600000f,0.491967300000f,0.465180000000f,0.439924600000f,0.416183600000f,0.393882200000f,0.372945900000f,0.353300000000f,0.334857800000f,0.317552100000f,0.301337500000f,0.286168600000f,0.272000000000f,0.258817100000f,0.246483800000f,0.234771800000f,0.223453300000f,0.212300000000f,0.201169200000f,0.190119600000f,0.179225400000f,0.168560800000f,0.158200000000f,0.148138300000f,0.138375800000f,0.128994200000f,0.120075100000f,0.111700000000f,0.103904800000f,0.096667480000f,0.089982720000f,0.083845310000f,0.078249990000f,0.073208990000f,0.068678160000f,0.064567840000f,0.060788350000f,0.057250010000f,0.053904350000f,0.050746640000f,0.047752760000f,0.044898590000f,0.042160000000f,0.039507280000f,0.036935640000f,0.034458360000f,0.032088720000f,0.029840000000f,0.027711810000f,0.025694440000f,0.023787160000f,0.021989250000f,0.020300000000f,0.018718050000f,0.017240360000f,0.015863640000f,0.014584610000f,0.013400000000f,0.012307230000f,0.011301880000f,0.010377920000f,0.009529306000f,0.008749999000f,0.008035200000f,0.007381600000f,0.006785400000f,0.006242800000f,0.005749999000f,0.005303600000f,0.004899800000f,0.004534200000f,0.004202400000f,0.003900000000f,0.003623200000f,0.003370600000f,0.003141400000f,0.002934800000f,0.002749999000f,0.002585200000f,0.002438600000f,0.002309400000f,0.002196800000f,0.002100000000f,0.002017733000f,0.001948200000f,0.001889800000f,0.001840933000f,0.001800000000f,0.001766267000f,0.001737800000f,0.001711200000f,0.001683067000f,0.001650001000f,0.001610133000f,0.001564400000f,0.001513600000f,0.001458533000f,0.001400000000f,0.001336667000f,0.001270000000f,0.001205000000f,0.001146667000f,0.001100000000f,0.001068800000f,0.001049400000f,0.001035600000f,0.001021200000f,0.001000000000f,0.000968640000f,0.000929920000f,0.000886880000f,0.000842560000f,0.000800000000f,0.000760960000f,0.000723680000f,0.000685920000f,0.000645440000f,0.000600000000f,0.000547866700f,0.000491600000f,0.000435400000f,0.000383466700f,0.000340000000f,0.000307253300f,0.000283160000f,0.000265440000f,0.000251813300f,0.000240000000f,0.000229546700f,0.000220640000f,0.000211960000f,0.000202186700f,0.000190000000f,0.000174213300f,0.000155640000f,0.000135960000f,0.000116853300f,0.000100000000f,0.000086133330f,0.000074600000f,0.000065000000f,0.000056933330f,0.000049999990f,0.000044160000f,0.000039480000f,0.000035720000f,0.000032640000f,0.000030000000f,0.000027653330f,0.000025560000f,0.000023640000f,0.000021813330f,0.000020000000f,0.000018133330f,0.000016200000f,0.000014200000f,0.000012133330f,0.000010000000f,0.000007733333f,0.000005400000f,0.000003200000f,0.000001333333f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f };

	static float s_CIE_1964_10deg_min = 360.0f;
	static float s_CIE_1964_10deg_max = 830.0f;
#define s_CIE_1964_10deg_samplesCount 471
	static float s_CIE_1964_10deg_X[] = { 0.000000122200f,0.000000185138f,0.000000278830f,0.000000417470f,0.000000621330f,0.000000919270f,0.000001351980f,0.000001976540f,0.000002872500f,0.000004149500f,0.000005958600f,0.000008505600f,0.000012068600f,0.000017022600f,0.000023868000f,0.000033266000f,0.000046087000f,0.000063472000f,0.000086892000f,0.000118246000f,0.000159952000f,0.000215080000f,0.000287490000f,0.000381990000f,0.000504550000f,0.000662440000f,0.000864500000f,0.001121500000f,0.001446160000f,0.001853590000f,0.002361600000f,0.002990600000f,0.003764500000f,0.004710200000f,0.005858100000f,0.007242300000f,0.008899600000f,0.010870900000f,0.013198900000f,0.015929200000f,0.019109700000f,0.022788000000f,0.027011000000f,0.031829000000f,0.037278000000f,0.043400000000f,0.050223000000f,0.057764000000f,0.066038000000f,0.075033000000f,0.084736000000f,0.095041000000f,0.105836000000f,0.117066000000f,0.128682000000f,0.140638000000f,0.152893000000f,0.165416000000f,0.178191000000f,0.191214000000f,0.204492000000f,0.217650000000f,0.230267000000f,0.242311000000f,0.253793000000f,0.264737000000f,0.275195000000f,0.285301000000f,0.295143000000f,0.304869000000f,0.314679000000f,0.324355000000f,0.333570000000f,0.342243000000f,0.350312000000f,0.357719000000f,0.364482000000f,0.370493000000f,0.375727000000f,0.380158000000f,0.383734000000f,0.386327000000f,0.387858000000f,0.388396000000f,0.387978000000f,0.386726000000f,0.384696000000f,0.382006000000f,0.378709000000f,0.374915000000f,0.370702000000f,0.366089000000f,0.361045000000f,0.355518000000f,0.349486000000f,0.342957000000f,0.335893000000f,0.328284000000f,0.320150000000f,0.311475000000f,0.302273000000f,0.292858000000f,0.283502000000f,0.274044000000f,0.264263000000f,0.254085000000f,0.243392000000f,0.232187000000f,0.220488000000f,0.208198000000f,0.195618000000f,0.183034000000f,0.170222000000f,0.157348000000f,0.144650000000f,0.132349000000f,0.120584000000f,0.109456000000f,0.099042000000f,0.089388000000f,0.080507000000f,0.072034000000f,0.063710000000f,0.055694000000f,0.048117000000f,0.041072000000f,0.034642000000f,0.028896000000f,0.023876000000f,0.019628000000f,0.016172000000f,0.013300000000f,0.010759000000f,0.008542000000f,0.006661000000f,0.005132000000f,0.003982000000f,0.003239000000f,0.002934000000f,0.003114000000f,0.003816000000f,0.005095000000f,0.006936000000f,0.009299000000f,0.012147000000f,0.015444000000f,0.019156000000f,0.023250000000f,0.027690000000f,0.032444000000f,0.037465000000f,0.042956000000f,0.049114000000f,0.055920000000f,0.063349000000f,0.071358000000f,0.079901000000f,0.088909000000f,0.098293000000f,0.107949000000f,0.117749000000f,0.127839000000f,0.138450000000f,0.149516000000f,0.161041000000f,0.172953000000f,0.185209000000f,0.197755000000f,0.210538000000f,0.223460000000f,0.236491000000f,0.249633000000f,0.262972000000f,0.276515000000f,0.290269000000f,0.304213000000f,0.318361000000f,0.332705000000f,0.347232000000f,0.361926000000f,0.376772000000f,0.391683000000f,0.406594000000f,0.421539000000f,0.436517000000f,0.451584000000f,0.466782000000f,0.482147000000f,0.497738000000f,0.513606000000f,0.529826000000f,0.546440000000f,0.563426000000f,0.580726000000f,0.598290000000f,0.616053000000f,0.633948000000f,0.651901000000f,0.669824000000f,0.687632000000f,0.705224000000f,0.722773000000f,0.740483000000f,0.758273000000f,0.776083000000f,0.793832000000f,0.811436000000f,0.828822000000f,0.845879000000f,0.862525000000f,0.878655000000f,0.894208000000f,0.909206000000f,0.923672000000f,0.937638000000f,0.951162000000f,0.964283000000f,0.977068000000f,0.989590000000f,1.001910000000f,1.014160000000f,1.026500000000f,1.038800000000f,1.051000000000f,1.062900000000f,1.074300000000f,1.085200000000f,1.095200000000f,1.104200000000f,1.112000000000f,1.118520000000f,1.123800000000f,1.128000000000f,1.131100000000f,1.133200000000f,1.134300000000f,1.134300000000f,1.133300000000f,1.131200000000f,1.128100000000f,1.123990000000f,1.118900000000f,1.112900000000f,1.105900000000f,1.098000000000f,1.089100000000f,1.079200000000f,1.068400000000f,1.056700000000f,1.044000000000f,1.030480000000f,1.016000000000f,1.000800000000f,0.984790000000f,0.968080000000f,0.950740000000f,0.932800000000f,0.914340000000f,0.895390000000f,0.876030000000f,0.856297000000f,0.836350000000f,0.816290000000f,0.796050000000f,0.775610000000f,0.754930000000f,0.733990000000f,0.712780000000f,0.691290000000f,0.669520000000f,0.647467000000f,0.625110000000f,0.602520000000f,0.579890000000f,0.557370000000f,0.535110000000f,0.513240000000f,0.491860000000f,0.471080000000f,0.450960000000f,0.431567000000f,0.412870000000f,0.394750000000f,0.377210000000f,0.360190000000f,0.343690000000f,0.327690000000f,0.312170000000f,0.297110000000f,0.282500000000f,0.268329000000f,0.254590000000f,0.241300000000f,0.228480000000f,0.216140000000f,0.204300000000f,0.192950000000f,0.182110000000f,0.171770000000f,0.161920000000f,0.152568000000f,0.143670000000f,0.135200000000f,0.127130000000f,0.119480000000f,0.112210000000f,0.105310000000f,0.098786000000f,0.092610000000f,0.086773000000f,0.081260600000f,0.076048000000f,0.071114000000f,0.066454000000f,0.062062000000f,0.057930000000f,0.054050000000f,0.050412000000f,0.047006000000f,0.043823000000f,0.040850800000f,0.038072000000f,0.035468000000f,0.033031000000f,0.030753000000f,0.028623000000f,0.026635000000f,0.024781000000f,0.023052000000f,0.021441000000f,0.019941300000f,0.018544000000f,0.017241000000f,0.016027000000f,0.014896000000f,0.013842000000f,0.012862000000f,0.011949000000f,0.011100000000f,0.010311000000f,0.009576880000f,0.008894000000f,0.008258100000f,0.007666400000f,0.007116300000f,0.006605200000f,0.006130600000f,0.005690300000f,0.005281900000f,0.004903300000f,0.004552630000f,0.004227500000f,0.003925800000f,0.003645700000f,0.003385900000f,0.003144700000f,0.002920800000f,0.002713000000f,0.002520200000f,0.002341100000f,0.002174960000f,0.002020600000f,0.001877300000f,0.001744100000f,0.001620500000f,0.001505700000f,0.001399200000f,0.001300400000f,0.001208700000f,0.001123600000f,0.001044760000f,0.000971560000f,0.000903600000f,0.000840480000f,0.000781870000f,0.000727450000f,0.000676900000f,0.000629960000f,0.000586370000f,0.000545870000f,0.000508258000f,0.000473300000f,0.000440800000f,0.000410580000f,0.000382490000f,0.000356380000f,0.000332110000f,0.000309550000f,0.000288580000f,0.000269090000f,0.000250969000f,0.000234130000f,0.000218470000f,0.000203910000f,0.000190350000f,0.000177730000f,0.000165970000f,0.000155020000f,0.000144800000f,0.000135280000f,0.000126390000f,0.000118100000f,0.000110370000f,0.000103150000f,0.000096427000f,0.000090151000f,0.000084294000f,0.000078830000f,0.000073729000f,0.000068969000f,0.000064525800f,0.000060376000f,0.000056500000f,0.000052880000f,0.000049498000f,0.000046339000f,0.000043389000f,0.000040634000f,0.000038060000f,0.000035657000f,0.000033411700f,0.000031315000f,0.000029355000f,0.000027524000f,0.000025811000f,0.000024209000f,0.000022711000f,0.000021308000f,0.000019994000f,0.000018764000f,0.000017611500f,0.000016532000f,0.000015521000f,0.000014574000f,0.000013686000f,0.000012855000f,0.000012075000f,0.000011345000f,0.000010659000f,0.000010017000f,0.000009413630f,0.000008847900f,0.000008317100f,0.000007819000f,0.000007351600f,0.000006913000f,0.000006501500f,0.000006115300f,0.000005752900f,0.000005412700f,0.000005093470f,0.000004793800f,0.000004512500f,0.000004248300f,0.000004000200f,0.000003767100f,0.000003548000f,0.000003342100f,0.000003148500f,0.000002966500f,0.000002795310f,0.000002634500f,0.000002483400f,0.000002341400f,0.000002207800f,0.000002082000f,0.000001963600f,0.000001851900f,0.000001746500f,0.000001647100f,0.000001553140f };
	static float s_CIE_1964_10deg_Y[] = { 0.000000013398f,0.000000020294f,0.000000030560f,0.000000045740f,0.000000068050f,0.000000100650f,0.000000147980f,0.000000216270f,0.000000314200f,0.000000453700f,0.000000651100f,0.000000928800f,0.000001317500f,0.000001857200f,0.000002602000f,0.000003625000f,0.000005019000f,0.000006907000f,0.000009449000f,0.000012848000f,0.000017364000f,0.000023327000f,0.000031150000f,0.000041350000f,0.000054560000f,0.000071560000f,0.000093300000f,0.000120870000f,0.000155640000f,0.000199200000f,0.000253400000f,0.000320200000f,0.000402400000f,0.000502300000f,0.000623200000f,0.000768500000f,0.000941700000f,0.001147800000f,0.001390300000f,0.001674000000f,0.002004400000f,0.002386000000f,0.002822000000f,0.003319000000f,0.003880000000f,0.004509000000f,0.005209000000f,0.005985000000f,0.006833000000f,0.007757000000f,0.008756000000f,0.009816000000f,0.010918000000f,0.012058000000f,0.013237000000f,0.014456000000f,0.015717000000f,0.017025000000f,0.018399000000f,0.019848000000f,0.021391000000f,0.022992000000f,0.024598000000f,0.026213000000f,0.027841000000f,0.029497000000f,0.031195000000f,0.032927000000f,0.034738000000f,0.036654000000f,0.038676000000f,0.040792000000f,0.042946000000f,0.045114000000f,0.047333000000f,0.049602000000f,0.051934000000f,0.054337000000f,0.056822000000f,0.059399000000f,0.062077000000f,0.064737000000f,0.067285000000f,0.069764000000f,0.072218000000f,0.074704000000f,0.077272000000f,0.079979000000f,0.082874000000f,0.086000000000f,0.089456000000f,0.092947000000f,0.096275000000f,0.099535000000f,0.102829000000f,0.106256000000f,0.109901000000f,0.113835000000f,0.118167000000f,0.122932000000f,0.128201000000f,0.133457000000f,0.138323000000f,0.143042000000f,0.147787000000f,0.152761000000f,0.158102000000f,0.163941000000f,0.170362000000f,0.177425000000f,0.185190000000f,0.193025000000f,0.200313000000f,0.207156000000f,0.213644000000f,0.219940000000f,0.226170000000f,0.232467000000f,0.239025000000f,0.245997000000f,0.253589000000f,0.261876000000f,0.270643000000f,0.279645000000f,0.288694000000f,0.297665000000f,0.306469000000f,0.315035000000f,0.323335000000f,0.331366000000f,0.339133000000f,0.347860000000f,0.358326000000f,0.370001000000f,0.382464000000f,0.395379000000f,0.408482000000f,0.421588000000f,0.434619000000f,0.447601000000f,0.460777000000f,0.474340000000f,0.488200000000f,0.502340000000f,0.516740000000f,0.531360000000f,0.546190000000f,0.561180000000f,0.576290000000f,0.591500000000f,0.606741000000f,0.622150000000f,0.637830000000f,0.653710000000f,0.669680000000f,0.685660000000f,0.701550000000f,0.717230000000f,0.732570000000f,0.747460000000f,0.761757000000f,0.775340000000f,0.788220000000f,0.800460000000f,0.812140000000f,0.823330000000f,0.834120000000f,0.844600000000f,0.854870000000f,0.865040000000f,0.875211000000f,0.885370000000f,0.895370000000f,0.905150000000f,0.914650000000f,0.923810000000f,0.932550000000f,0.940810000000f,0.948520000000f,0.955600000000f,0.961988000000f,0.967540000000f,0.972230000000f,0.976170000000f,0.979460000000f,0.982200000000f,0.984520000000f,0.986520000000f,0.988320000000f,0.990020000000f,0.991761000000f,0.993530000000f,0.995230000000f,0.996770000000f,0.998090000000f,0.999110000000f,0.999770000000f,1.000000000000f,0.999710000000f,0.998850000000f,0.997340000000f,0.995260000000f,0.992740000000f,0.989750000000f,0.986300000000f,0.982380000000f,0.977980000000f,0.973110000000f,0.967740000000f,0.961890000000f,0.955552000000f,0.948601000000f,0.940981000000f,0.932798000000f,0.924158000000f,0.915175000000f,0.905954000000f,0.896608000000f,0.887249000000f,0.877986000000f,0.868934000000f,0.860164000000f,0.851519000000f,0.842963000000f,0.834393000000f,0.825623000000f,0.816764000000f,0.807544000000f,0.797947000000f,0.787893000000f,0.777405000000f,0.766490000000f,0.755309000000f,0.743845000000f,0.732190000000f,0.720353000000f,0.708281000000f,0.696055000000f,0.683621000000f,0.671048000000f,0.658341000000f,0.645545000000f,0.632718000000f,0.619815000000f,0.606887000000f,0.593878000000f,0.580781000000f,0.567653000000f,0.554490000000f,0.541228000000f,0.527963000000f,0.514634000000f,0.501363000000f,0.488124000000f,0.474935000000f,0.461834000000f,0.448823000000f,0.435917000000f,0.423153000000f,0.410526000000f,0.398057000000f,0.385835000000f,0.373951000000f,0.362311000000f,0.350863000000f,0.339554000000f,0.328309000000f,0.317118000000f,0.305936000000f,0.294737000000f,0.283493000000f,0.272222000000f,0.260990000000f,0.249877000000f,0.238946000000f,0.228254000000f,0.217853000000f,0.207780000000f,0.198072000000f,0.188748000000f,0.179828000000f,0.171285000000f,0.163059000000f,0.155151000000f,0.147535000000f,0.140211000000f,0.133170000000f,0.126400000000f,0.119892000000f,0.113640000000f,0.107633000000f,0.101870000000f,0.096347000000f,0.091063000000f,0.086010000000f,0.081187000000f,0.076583000000f,0.072198000000f,0.068024000000f,0.064052000000f,0.060281000000f,0.056697000000f,0.053292000000f,0.050059000000f,0.046998000000f,0.044096000000f,0.041345000000f,0.038750700000f,0.036297800000f,0.033983200000f,0.031800400000f,0.029739500000f,0.027791800000f,0.025955100000f,0.024226300000f,0.022601700000f,0.021077900000f,0.019650500000f,0.018315300000f,0.017068600000f,0.015905100000f,0.014818300000f,0.013800800000f,0.012849500000f,0.011960700000f,0.011130300000f,0.010355500000f,0.009633200000f,0.008959900000f,0.008332400000f,0.007748800000f,0.007204600000f,0.006697500000f,0.006225100000f,0.005785000000f,0.005375100000f,0.004994100000f,0.004639200000f,0.004309300000f,0.004002800000f,0.003717740000f,0.003452620000f,0.003205830000f,0.002976230000f,0.002762810000f,0.002564560000f,0.002380480000f,0.002209710000f,0.002051320000f,0.001904490000f,0.001768470000f,0.001642360000f,0.001525350000f,0.001416720000f,0.001315950000f,0.001222390000f,0.001135550000f,0.001054940000f,0.000980140000f,0.000910660000f,0.000846190000f,0.000786290000f,0.000730680000f,0.000678990000f,0.000631010000f,0.000586440000f,0.000545110000f,0.000506720000f,0.000471110000f,0.000438050000f,0.000407410000f,0.000378962000f,0.000352543000f,0.000328001000f,0.000305208000f,0.000284041000f,0.000264375000f,0.000246109000f,0.000229143000f,0.000213376000f,0.000198730000f,0.000185115000f,0.000172454000f,0.000160678000f,0.000149730000f,0.000139550000f,0.000130086000f,0.000121290000f,0.000113106000f,0.000105501000f,0.000098428000f,0.000091853000f,0.000085738000f,0.000080048000f,0.000074751000f,0.000069819000f,0.000065222000f,0.000060939000f,0.000056942000f,0.000053217000f,0.000049737000f,0.000046491000f,0.000043464000f,0.000040635000f,0.000038000000f,0.000035540500f,0.000033244800f,0.000031100600f,0.000029099000f,0.000027230700f,0.000025486000f,0.000023856100f,0.000022333200f,0.000020910400f,0.000019580800f,0.000018338400f,0.000017177700f,0.000016093400f,0.000015080000f,0.000014133600f,0.000013249000f,0.000012422600f,0.000011649900f,0.000010927700f,0.000010251900f,0.000009619600f,0.000009028100f,0.000008474000f,0.000007954800f,0.000007468600f,0.000007012800f,0.000006585800f,0.000006185700f,0.000005810700f,0.000005459000f,0.000005129800f,0.000004820600f,0.000004531200f,0.000004259100f,0.000004004200f,0.000003764730f,0.000003539950f,0.000003329140f,0.000003131150f,0.000002945290f,0.000002770810f,0.000002607050f,0.000002453290f,0.000002308940f,0.000002173380f,0.000002046130f,0.000001926620f,0.000001814400f,0.000001708950f,0.000001609880f,0.000001516770f,0.000001429210f,0.000001346860f,0.000001269450f,0.000001196620f,0.000001128090f,0.000001063680f,0.000001003130f,0.000000946220f,0.000000892630f,0.000000842160f,0.000000794640f,0.000000749780f,0.000000707440f,0.000000667480f,0.000000629700f };
	static float s_CIE_1964_10deg_Z[] = { 0.000000535027f,0.000000810720f,0.000001221200f,0.000001828700f,0.000002722200f,0.000004028300f,0.000005925700f,0.000008665100f,0.000012596000f,0.000018201000f,0.000026143700f,0.000037330000f,0.000052987000f,0.000074764000f,0.000104870000f,0.000146220000f,0.000202660000f,0.000279230000f,0.000382450000f,0.000520720000f,0.000704776000f,0.000948230000f,0.001268200000f,0.001686100000f,0.002228500000f,0.002927800000f,0.003823700000f,0.004964200000f,0.006406700000f,0.008219300000f,0.010482200000f,0.013289000000f,0.016747000000f,0.020980000000f,0.026127000000f,0.032344000000f,0.039802000000f,0.048691000000f,0.059210000000f,0.071576000000f,0.086010900000f,0.102740000000f,0.122000000000f,0.144020000000f,0.168990000000f,0.197120000000f,0.228570000000f,0.263470000000f,0.301900000000f,0.343870000000f,0.389366000000f,0.437970000000f,0.489220000000f,0.542900000000f,0.598810000000f,0.656760000000f,0.716580000000f,0.778120000000f,0.841310000000f,0.906110000000f,0.972542000000f,1.038900000000f,1.103100000000f,1.165100000000f,1.224900000000f,1.282500000000f,1.338200000000f,1.392600000000f,1.446100000000f,1.499400000000f,1.553480000000f,1.607200000000f,1.658900000000f,1.708200000000f,1.754800000000f,1.798500000000f,1.839200000000f,1.876600000000f,1.910500000000f,1.940800000000f,1.967280000000f,1.989100000000f,2.005700000000f,2.017400000000f,2.024400000000f,2.027300000000f,2.026400000000f,2.022300000000f,2.015300000000f,2.006000000000f,1.994800000000f,1.981400000000f,1.965300000000f,1.946400000000f,1.924800000000f,1.900700000000f,1.874100000000f,1.845100000000f,1.813900000000f,1.780600000000f,1.745370000000f,1.709100000000f,1.672300000000f,1.634700000000f,1.595600000000f,1.554900000000f,1.512200000000f,1.467300000000f,1.419900000000f,1.370000000000f,1.317560000000f,1.262400000000f,1.205000000000f,1.146600000000f,1.088000000000f,1.030200000000f,0.973830000000f,0.919430000000f,0.867460000000f,0.818280000000f,0.772125000000f,0.728290000000f,0.686040000000f,0.645530000000f,0.606850000000f,0.570060000000f,0.535220000000f,0.502340000000f,0.471400000000f,0.442390000000f,0.415254000000f,0.390024000000f,0.366399000000f,0.344015000000f,0.322689000000f,0.302356000000f,0.283036000000f,0.264816000000f,0.247848000000f,0.232318000000f,0.218502000000f,0.205851000000f,0.193596000000f,0.181736000000f,0.170281000000f,0.159249000000f,0.148673000000f,0.138609000000f,0.129096000000f,0.120215000000f,0.112044000000f,0.104710000000f,0.098196000000f,0.092361000000f,0.087088000000f,0.082248000000f,0.077744000000f,0.073456000000f,0.069268000000f,0.065060000000f,0.060709000000f,0.056457000000f,0.052609000000f,0.049122000000f,0.045954000000f,0.043050000000f,0.040368000000f,0.037839000000f,0.035384000000f,0.032949000000f,0.030451000000f,0.028029000000f,0.025862000000f,0.023920000000f,0.022174000000f,0.020584000000f,0.019127000000f,0.017740000000f,0.016403000000f,0.015064000000f,0.013676000000f,0.012308000000f,0.011056000000f,0.009915000000f,0.008872000000f,0.007918000000f,0.007030000000f,0.006223000000f,0.005453000000f,0.004714000000f,0.003988000000f,0.003289000000f,0.002646000000f,0.002063000000f,0.001533000000f,0.001091000000f,0.000711000000f,0.000407000000f,0.000184000000f,0.000047000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f,0.000000000000f };

	// src: https://github.com/hughsie/colord/tree/main/data/illuminant
	static float s_Illuminance_D65_min = 300.0f;
	static float s_Illuminance_D65_max = 830.0f;
#define s_Illuminance_D65_samplesCount 531
	static float s_Illuminance_D65[] = { 0.034100f,0.360140f,0.686180f,1.012220f,1.338260f,1.664300f,1.990340f,2.316380f,2.642420f,2.968460f,3.294500f,4.988650f,6.682800f,8.376950f,10.071100f,11.765200f,13.459400f,15.153500f,16.847700f,18.541800f,20.236000f,21.917700f,23.599500f,25.281200f,26.963000f,28.644700f,30.326500f,32.008200f,33.690000f,35.371700f,37.053500f,37.343000f,37.632600f,37.922100f,38.211600f,38.501100f,38.790700f,39.080200f,39.369700f,39.659300f,39.948800f,40.445100f,40.941400f,41.437700f,41.934000f,42.430200f,42.926500f,43.422800f,43.919100f,44.415400f,44.911700f,45.084400f,45.257000f,45.429700f,45.602300f,45.775000f,45.947700f,46.120300f,46.293000f,46.465600f,46.638300f,47.183400f,47.728500f,48.273500f,48.818600f,49.363700f,49.908800f,50.453900f,50.998900f,51.544000f,52.089100f,51.877700f,51.666400f,51.455000f,51.243700f,51.032300f,50.820900f,50.609600f,50.398200f,50.186900f,49.975500f,50.442800f,50.910000f,51.377300f,51.844600f,52.311800f,52.779100f,53.246400f,53.713700f,54.180900f,54.648200f,57.458900f,60.269500f,63.080200f,65.890900f,68.701500f,71.512200f,74.322900f,77.133600f,79.944200f,82.754900f,83.628000f,84.501100f,85.374200f,86.247300f,87.120400f,87.993600f,88.866700f,89.739800f,90.612900f,91.486000f,91.680600f,91.875200f,92.069700f,92.264300f,92.458900f,92.653500f,92.848100f,93.042600f,93.237200f,93.431800f,92.756800f,92.081900f,91.406900f,90.732000f,90.057000f,89.382100f,88.707100f,88.032200f,87.357200f,86.682300f,88.500600f,90.318800f,92.137100f,93.955400f,95.773600f,97.591900f,99.410200f,101.228000f,103.047000f,104.865000f,106.079000f,107.294000f,108.508000f,109.722000f,110.936000f,112.151000f,113.365000f,114.579000f,115.794000f,117.008000f,117.088000f,117.169000f,117.249000f,117.330000f,117.410000f,117.490000f,117.571000f,117.651000f,117.732000f,117.812000f,117.517000f,117.222000f,116.927000f,116.632000f,116.336000f,116.041000f,115.746000f,115.451000f,115.156000f,114.861000f,114.967000f,115.073000f,115.180000f,115.286000f,115.392000f,115.498000f,115.604000f,115.711000f,115.817000f,115.923000f,115.212000f,114.501000f,113.789000f,113.078000f,112.367000f,111.656000f,110.945000f,110.233000f,109.522000f,108.811000f,108.865000f,108.920000f,108.974000f,109.028000f,109.082000f,109.137000f,109.191000f,109.245000f,109.300000f,109.354000f,109.199000f,109.044000f,108.888000f,108.733000f,108.578000f,108.423000f,108.268000f,108.112000f,107.957000f,107.802000f,107.501000f,107.200000f,106.898000f,106.597000f,106.296000f,105.995000f,105.694000f,105.392000f,105.091000f,104.790000f,105.080000f,105.370000f,105.660000f,105.950000f,106.239000f,106.529000f,106.819000f,107.109000f,107.399000f,107.689000f,107.361000f,107.032000f,106.704000f,106.375000f,106.047000f,105.719000f,105.390000f,105.062000f,104.733000f,104.405000f,104.369000f,104.333000f,104.297000f,104.261000f,104.225000f,104.190000f,104.154000f,104.118000f,104.082000f,104.046000f,103.641000f,103.237000f,102.832000f,102.428000f,102.023000f,101.618000f,101.214000f,100.809000f,100.405000f,100.000000f,99.633400f,99.266800f,98.900300f,98.533700f,98.167100f,97.800500f,97.433900f,97.067400f,96.700800f,96.334200f,96.279600f,96.225000f,96.170300f,96.115700f,96.061100f,96.006500f,95.951900f,95.897200f,95.842600f,95.788000f,95.077800f,94.367500f,93.657300f,92.947000f,92.236800f,91.526600f,90.816300f,90.106100f,89.395800f,88.685600f,88.817700f,88.949700f,89.081800f,89.213800f,89.345900f,89.478000f,89.610000f,89.742100f,89.874100f,90.006200f,89.965500f,89.924800f,89.884100f,89.843400f,89.802600f,89.761900f,89.721200f,89.680500f,89.639800f,89.599100f,89.409100f,89.219000f,89.029000f,88.838900f,88.648900f,88.458900f,88.268800f,88.078800f,87.888700f,87.698700f,87.257700f,86.816700f,86.375700f,85.934700f,85.493600f,85.052600f,84.611600f,84.170600f,83.729600f,83.288600f,83.329700f,83.370700f,83.411800f,83.452800f,83.493900f,83.535000f,83.576000f,83.617100f,83.658100f,83.699200f,83.332000f,82.964700f,82.597500f,82.230200f,81.863000f,81.495800f,81.128500f,80.761300f,80.394000f,80.026800f,80.045600f,80.064400f,80.083100f,80.101900f,80.120700f,80.139500f,80.158300f,80.177000f,80.195800f,80.214600f,80.420900f,80.627200f,80.833600f,81.039900f,81.246200f,81.452500f,81.658800f,81.865200f,82.071500f,82.277800f,81.878400f,81.479100f,81.079700f,80.680400f,80.281000f,79.881600f,79.482300f,79.082900f,78.683600f,78.284200f,77.427900f,76.571600f,75.715300f,74.859000f,74.002700f,73.146500f,72.290200f,71.433900f,70.577600f,69.721300f,69.910100f,70.098900f,70.287600f,70.476400f,70.665200f,70.854000f,71.042800f,71.231500f,71.420300f,71.609100f,71.883100f,72.157100f,72.431100f,72.705100f,72.979000f,73.253000f,73.527000f,73.801000f,74.075000f,74.349000f,73.074500f,71.800000f,70.525500f,69.251000f,67.976500f,66.702000f,65.427500f,64.153000f,62.878500f,61.604000f,62.432200f,63.260300f,64.088500f,64.916600f,65.744800f,66.573000f,67.401100f,68.229300f,69.057400f,69.885600f,70.405700f,70.925900f,71.446000f,71.966200f,72.486300f,73.006400f,73.526600f,74.046700f,74.566900f,75.087000f,73.937600f,72.788100f,71.638700f,70.489300f,69.339800f,68.190400f,67.041000f,65.891600f,64.742100f,63.592700f,61.875200f,60.157800f,58.440300f,56.722900f,55.005400f,53.288000f,51.570500f,49.853100f,48.135600f,46.418200f,48.456900f,50.495600f,52.534400f,54.573100f,56.611800f,58.650500f,60.689200f,62.728000f,64.766700f,66.805400f,66.463100f,66.120900f,65.778600f,65.436400f,65.094100f,64.751800f,64.409600f,64.067300f,63.725100f,63.382800f,63.474900f,63.567000f,63.659200f,63.751300f,63.843400f,63.935500f,64.027600f,64.119800f,64.211900f,64.304000f,63.818800f,63.333600f,62.848400f,62.363200f,61.877900f,61.392700f,60.907500f,60.422300f,59.937100f,59.451900f,58.702600f,57.953300f,57.204000f,56.454700f,55.705400f,54.956200f,54.206900f,53.457600f,52.708300f,51.959000f,52.507200f,53.055300f,53.603500f,54.151600f,54.699800f,55.248000f,55.796100f,56.344300f,56.892400f,57.440600f,57.727800f,58.015000f,58.302200f,58.589400f,58.876500f,59.163700f,59.450900f,59.738100f,60.025300f,60.312500f };

	static float s_Illuminance_D50_min = 300.0f;
	static float s_Illuminance_D50_max = 780.0f;
#define s_Illuminance_D50_samplesCount 97
	static float s_Illuminance_D50[] = { 0.019f,1.035f,2.051f,4.914f,7.778f,11.263f,14.748f,16.348f,17.948f,19.479f,21.010f,22.476f,23.942f,25.451f,26.961f,25.724f,24.488f,27.179f,29.871f,39.589f,49.308f,52.910f,56.513f,58.273f,60.034f,58.926f,57.818f,66.321f,74.825f,81.036f,87.247f,88.930f,90.612f,90.990f,91.368f,93.238f,95.109f,93.536f,91.963f,93.843f,95.724f,96.169f,96.613f,96.871f,97.129f,99.614f,102.099f,101.427f,100.755f,101.536f,102.317f,101.159f,100.000f,98.868f,97.735f,98.327f,98.918f,96.208f,93.499f,95.593f,97.688f,98.478f,99.269f,99.155f,99.042f,97.382f,95.722f,97.290f,98.857f,97.262f,95.667f,96.929f,98.190f,100.597f,103.003f,101.068f,99.133f,93.257f,87.381f,89.492f,91.604f,92.246f,92.889f,84.872f,76.854f,81.683f,86.511f,89.546f,92.580f,85.405f,78.230f,67.961f,57.692f,70.307f,82.923f,80.599f,78.274f };

	static float s_Illuminance_C_min = 380.0f;
	static float s_Illuminance_C_max = 780.0f;
#define s_Illuminance_C_samplesCount 81
	static float s_Illuminance_C[] = { 33.00f, 39.92f, 47.40f, 55.17f, 63.30f, 71.81f, 80.60f, 89.53f, 98.10f, 105.80f, 112.40f, 117.75f, 121.50f, 123.45f, 124.00f, 123.60f, 123.10f, 123.30f, 123.80f, 124.09f, 123.90f, 122.92f, 120.70f, 116.90f, 112.10f, 106.98f, 102.30f, 98.81f, 96.90f, 96.78f, 98.00f, 99.94f, 102.10f, 103.95f, 105.20f, 105.67f, 105.30f, 104.11f, 102.30f, 100.15f, 97.80f, 95.43f, 93.20f, 91.22f, 89.70f, 88.83f, 88.40f, 88.19f, 88.10f, 88.06f, 88.00f, 87.86f, 87.80f, 87.99f, 88.20f, 88.20f, 87.90f, 87.22f, 86.30f, 85.30f, 84.00f, 82.21f, 80.20f, 78.24f, 76.30f, 74.36f, 72.40f, 70.40f, 68.30f, 66.30f, 64.40f, 62.80f, 61.50f, 60.20f, 59.20f, 58.50f, 58.10f, 58.00f, 58.20f, 58.50f, 59.10f };

	static float s_Illuminance_E_min = 380.0f;
	static float s_Illuminance_E_max = 830.0f;
#define s_Illuminance_E_samplesCount 91
	static float s_Illuminance_E[] = { 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f, 100.0f };

	static float* s_CIE_Observers_X[] = { s_CIE_1931_2deg_X, s_CIE_1964_10deg_X };
	static float* s_CIE_Observers_Y[] = { s_CIE_1931_2deg_Y, s_CIE_1964_10deg_Y };
	static float* s_CIE_Observers_Z[] = { s_CIE_1931_2deg_Z, s_CIE_1964_10deg_Z };
	static float s_CIE_Observers_min[] = { s_CIE_1931_2deg_min, s_CIE_1964_10deg_min };
	static float s_CIE_Observers_max[] = { s_CIE_1931_2deg_max, s_CIE_1964_10deg_max };
	static int s_CIE_Observers_SamplesCount[] = { s_CIE_1931_2deg_samplesCount, s_CIE_1964_10deg_samplesCount };

	static float* s_Illums[] = { s_Illuminance_D50, s_Illuminance_D65, s_Illuminance_D50, s_Illuminance_D50, s_Illuminance_D65, s_Illuminance_E, s_Illuminance_D50, s_Illuminance_D50, s_Illuminance_D50, s_Illuminance_D50, s_Illuminance_C, s_Illuminance_D65, s_Illuminance_D50, s_Illuminance_D65, s_Illuminance_D65, s_Illuminance_D50 };
	static float s_Illums_min[] = { s_Illuminance_D50_min, s_Illuminance_D65_min, s_Illuminance_D50_min, s_Illuminance_D50_min, s_Illuminance_D65_min, s_Illuminance_E_min, s_Illuminance_D50_min, s_Illuminance_D50_min, s_Illuminance_D50_min, s_Illuminance_D50_min, s_Illuminance_C_min, s_Illuminance_D65_min, s_Illuminance_D50_min, s_Illuminance_D65_min, s_Illuminance_D65_min, s_Illuminance_D50_min };
	static float s_Illums_max[] = { s_Illuminance_D50_max, s_Illuminance_D65_max, s_Illuminance_D50_max, s_Illuminance_D50_max, s_Illuminance_D65_max, s_Illuminance_E_max, s_Illuminance_D50_max, s_Illuminance_D50_max, s_Illuminance_D50_max, s_Illuminance_D50_max, s_Illuminance_C_max, s_Illuminance_D65_max, s_Illuminance_D50_max, s_Illuminance_D65_max, s_Illuminance_D65_max, s_Illuminance_D50_max };
	static int s_Illums_SamplesCount[] = { s_Illuminance_D50_samplesCount, s_Illuminance_D65_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_D65_samplesCount, s_Illuminance_E_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_C_samplesCount, s_Illuminance_D65_samplesCount, s_Illuminance_D50_samplesCount, s_Illuminance_D65_samplesCount, s_Illuminance_D65_samplesCount, s_Illuminance_D50_samplesCount };

	static float s_min_kelvin_temp = 1000.0f;
	static float s_max_kelvin_temp = 12000.0f;
	static float s_kelvin_temp_count = 111;
	static float s_kelvin_sRGB_Colors_Red[] = {
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		255,
		254,
		252,
		249,
		247,
		245,
		243,
		240,
		239,
		237,
		235,
		233,
		231,
		230,
		228,
		227,
		225,
		224,
		222,
		221,
		220,
		218,
		217,
		216,
		215,
		214,
		212,
		211,
		210,
		209,
		208,
		207,
		207,
		206,
		205,
		207,
		207,
		206,
		205,
		204,
		204,
		203,
		202,
		202,
		201,
		200,
		200,
		199,
		198,
		198,
		197,
		197,
		197,
		196,
		195,
		195 };
	static float s_kelvin_sRGB_Colors_Green[] = {
		 56,
		 71,
		 83,
		 93,
		101,
		109,
		115,
		121,
		126,
		131,
		138,
		142,
		147,
		152,
		157,
		161,
		165,
		169,
		173,
		177,
		180,
		184,
		187,
		190,
		193,
		196,
		199,
		201,
		204,
		206,
		209,
		211,
		213,
		215,
		217,
		219,
		221,
		223,
		225,
		227,
		228,
		230,
		232,
		233,
		235,
		236,
		238,
		239,
		240,
		242,
		243,
		244,
		245,
		246,
		248,
		249,
		249,
		247,
		246,
		245,
		243,
		242,
		241,
		240,
		239,
		238,
		237,
		236,
		235,
		234,
		233,
		232,
		231,
		230,
		230,
		229,
		229,
		227,
		227,
		226,
		225,
		225,
		224,
		223,
		223,
		222,
		221,
		221,
		220,
		220,
		218,
		218,
		217,
		217,
		216,
		216,
		215,
		215,
		214,
		214,
		213,
		213,
		212,
		212,
		212,
		211,
		211,
		210,
		210,
		210,
		209 };
		static float s_kelvin_sRGB_Colors_Blue[] = {
			  0,
			  0,
			  0,
			  0,
			  0,
			  0,
			  0,
			  0,
			  0,
			  0,
			 18,
			 33,
			 44,
			 54,
			 63,
			 72,
			 79,
			 87,
			 94,
			101,
			107,
			114,
			120,
			126,
			132,
			137,
			143,
			148,
			153,
			159,
			163,
			168,
			173,
			177,
			182,
			186,
			190,
			194,
			198,
			202,
			206,
			210,
			213,
			217,
			220,
			224,
			227,
			230,
			233,
			236,
			239,
			242,
			245,
			247,
			251,
			253,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255,
			255 };

	// White Points
	// { 1932-2° {x, y}, 1964-10° {x, y}, Temperature Kelvin }
	static ImVec2 s_WhitePoints_Values[][ 2 ] =
	{
		{ ImVec2( 0.44757f, 0.40745f ), ImVec2( 0.45117f, 0.40594f ) }, // A:	incandescent / tungsten
		{ ImVec2( 0.34842f, 0.35161f ), ImVec2( 0.34980f, 0.35270f ) }, // B:	obsolete, direct sunlight at noon
		{ ImVec2( 0.31006f, 0.31616f ), ImVec2( 0.31039f, 0.31905f ) }, // C:	obsolete, average / North sky daylight
		{ ImVec2( 0.34567f, 0.35850f ), ImVec2( 0.34773f, 0.35952f ) }, // D50:	horizon light, ICC profile PCS
		{ ImVec2( 0.33242f, 0.34743f ), ImVec2( 0.33411f, 0.34877f ) }, // D55:	mid-morning / mid-afternoon daylight
		{ ImVec2( 0.31271f, 0.32902f ), ImVec2( 0.31382f, 0.33100f ) }, // D65:	noon daylight: television, sRGB color space
		{ ImVec2( 0.29902f, 0.31485f ), ImVec2( 0.29968f, 0.31740f ) }, // D75:	North sky daylight
		{ ImVec2( 0.28315f, 0.29711f ), ImVec2( 0.28327f, 0.30043f ) }, // D93:	high-efficiency blue phosphor monitors, BT.2035
		{ ImVec2( 0.33333f, 0.33333f ), ImVec2( 0.33333f, 0.33333f ) }, // E:	equal energy
		{ ImVec2( 0.31310f, 0.33727f ), ImVec2( 0.31811f, 0.33559f ) }, // F1:	daylight fluorescent
		{ ImVec2( 0.37208f, 0.37529f ), ImVec2( 0.37925f, 0.36733f ) }, // F2:	cool white fluorescent
		{ ImVec2( 0.40910f, 0.39430f ), ImVec2( 0.41761f, 0.38324f ) }, // F3:	white fluorescent
		{ ImVec2( 0.44018f, 0.40329f ), ImVec2( 0.44920f, 0.39074f ) }, // F4:	warm white fluorescent
		{ ImVec2( 0.31379f, 0.34531f ), ImVec2( 0.31975f, 0.34246f ) }, // F5:	daylight fluorescent
		{ ImVec2( 0.37790f, 0.38835f ), ImVec2( 0.38660f, 0.37847f ) }, // F6:	light white fluorescent
		{ ImVec2( 0.31292f, 0.32933f ), ImVec2( 0.31569f, 0.32960f ) }, // F7:	D65 simulator, daylight simulator
		{ ImVec2( 0.34588f, 0.35875f ), ImVec2( 0.34902f, 0.35939f ) }, // F8:	D50 simulator, Sylvania F40 Design 50
		{ ImVec2( 0.37417f, 0.37281f ), ImVec2( 0.37829f, 0.37045f ) }, // F9:	cool white deluxe fluorescent
		{ ImVec2( 0.34609f, 0.35986f ), ImVec2( 0.35090f, 0.35444f ) }, // F10:	Philips TL85, Ultralume 50
		{ ImVec2( 0.38052f, 0.37713f ), ImVec2( 0.38541f, 0.37123f ) }, // F11:	Philips TL84, Ultralume 40
		{ ImVec2( 0.43695f, 0.40441f ), ImVec2( 0.44256f, 0.39717f ) }  // F12:	Philips TL83, Ultralume 30
	};

	static float s_WhitePoints_Temperature[] =
	{
		2856.0f, 4874.0f, 6774.0f, 5003.0f, 5503.0f, 6504.0f, 7504.0f,
		9305.0f, 5454.0f, 6430.0f, 4230.0f, 3450.0f, 2940.0f, 6350.0f,
		4150.0f, 6500.0f, 5000.0f, 4150.0f, 5000.0f, 4000.0f, 3000.0f
	};

	// Color Space
	static float s_ColorSpace_XYZ2RGB_AdobeRGB[] = { 2.0413690f, -0.5649464f, -0.3446944, -0.9692660f, 1.8760108f, 0.0415560, 0.0134474f, -0.1183897f, 1.0154096f };
	static float s_ColorSpace_XYZ2RGB_AppleRGB[] = { 2.9515373f, -1.2894116f, -0.4738445f, -1.0851093f, 1.9908566f, 0.0372026f, 0.0854934f, -0.2694964f, 1.0912975f };
	static float s_ColorSpace_XYZ2RGB_Best[] = { 1.7552599f, -0.4836786f, -0.2530000f, -0.5441336f, 1.5068789f, 0.0215528f, 0.0063467f, -0.0175761f, 1.2256959f };
	static float s_ColorSpace_XYZ2RGB_Beta[] = { 1.6832270f, -0.4282363f, -0.2360185f, -0.7710229f, 1.7065571f, 0.0446900f, 0.0400013f, -0.0885376f, 1.2723640f };
	static float s_ColorSpace_XYZ2RGB_Bruce[] = { 2.7454669f, -1.1358136f, -0.4350269f, -0.9692660f, 1.8760108f, 0.0415560f, 0.0112723f, -0.1139754f, 1.0132541f };
	static float s_ColorSpace_XYZ2RGB_CIERGB[] = { 2.3706743f, -0.9000405f, -0.4706338f, -0.5138850f, 1.4253036f, 0.0885814f, 0.0052982f, -0.0146949f, 1.0093968f };
	static float s_ColorSpace_XYZ2RGB_ColorMatch[] = { 2.6422874f, -1.2234270f, -0.3930143f, -1.1119763f, 2.0590183f, 0.0159614f, 0.0821699f, -0.2807254f, 1.4559877f };
	static float s_ColorSpace_XYZ2RGB_DonRGB4[] = { 1.7603902f, -0.4881198f, -0.2536126f, -0.7126288f, 1.6527432f, 0.0416715f, 0.0078207f, -0.0347411f, 1.2447743f };
	static float s_ColorSpace_XYZ2RGB_ECI[] = { 1.7827618f, -0.4969847f, -0.2690101f, -0.9593623f, 1.9477962f, -0.0275807f, 0.0859317f, -0.1744674f, 1.3228273f };
	static float s_ColorSpace_XYZ2RGB_EktaSpacePS5[] = { 2.0043819f, -0.7304844f, -0.2450052f, -0.7110285f, 1.6202126f, 0.0792227f, 0.0381263f, -0.0868780f, 1.2725438 };
	static float s_ColorSpace_XYZ2RGB_NTSC[] = { 1.9099961f, -0.5324542f, -0.2882091f, -0.9846663f, 1.9991710f, -0.0283082f, 0.0583056f, -0.1183781f, 0.8975535f };
	static float s_ColorSpace_XYZ2RGB_PAL_SECAM[] = { 3.0628971f, -1.3931791f, -0.4757517f, -0.9692660f, 1.8760108f, 0.0415560f, 0.0678775f, -0.2288548f, 1.0693490f };
	static float s_ColorSpace_XYZ2RGB_ProPhoto[] = { 1.3459433f, -0.2556075f, -0.0511118f, -0.5445989f, 1.5081673f, 0.0205351f, 0.0000000f, 0.0000000f, 1.2118128f };
	static float s_ColorSpace_XYZ2RGB_SMPTE_C[] = { 3.5053960f, -1.7394894f, -0.5439640f, -1.0690722f, 1.9778245f, 0.0351722f, 0.0563200f, -0.1970226f, 1.0502026f };
	static float s_ColorSpace_XYZ2RGB_sRGB[] = { 3.2404542f, -1.5371385f, -0.4985314f, -0.9692660f, 1.8760108f, 0.0415560f, 0.0556434f, -0.2040259f, 1.0572252f };
	static float s_ColorSpace_XYZ2RGB_WideGamutRGB[] = { 1.4628067f, -0.1840623f, -0.2743606f, -0.5217933f, 1.4472381f, 0.0677227f, 0.0349342f, -0.0968930f, 1.2884099f };
	static float s_ColorSpace_XYZ2RGB_Rec2020[] = { 1.7166512f, -0.3556708f, -0.2533663f, -0.6666844f, 1.6164812f, 0.0157685f, 0.0176399f, -0.0427706f, 0.9421031f };
	static float* s_ColorSpace_XYZ2RGB[] = {
		s_ColorSpace_XYZ2RGB_AdobeRGB,
		s_ColorSpace_XYZ2RGB_AppleRGB,
		s_ColorSpace_XYZ2RGB_Best,
		s_ColorSpace_XYZ2RGB_Beta,
		s_ColorSpace_XYZ2RGB_Bruce,
		s_ColorSpace_XYZ2RGB_CIERGB,
		s_ColorSpace_XYZ2RGB_ColorMatch,
		s_ColorSpace_XYZ2RGB_DonRGB4,
		s_ColorSpace_XYZ2RGB_ECI,
		s_ColorSpace_XYZ2RGB_EktaSpacePS5,
		s_ColorSpace_XYZ2RGB_NTSC,
		s_ColorSpace_XYZ2RGB_PAL_SECAM,
		s_ColorSpace_XYZ2RGB_ProPhoto,
		s_ColorSpace_XYZ2RGB_SMPTE_C,
		s_ColorSpace_XYZ2RGB_sRGB,
		s_ColorSpace_XYZ2RGB_WideGamutRGB,
		s_ColorSpace_XYZ2RGB_Rec2020 };
	static float s_ColorSpace_RGB2XYZ_AdobeRGB[]     = { 0.5767309f, 0.1855540f, 0.1881852f, 0.2973769f, 0.6273491f, 0.0752741f, 0.0270343f, 0.0706872f, 0.9911085f };
	static float s_ColorSpace_RGB2XYZ_AppleRGB[]     = { 0.4497288f, 0.3162486f, 0.1844926f, 0.2446525f, 0.6720283f, 0.0833192f, 0.0251848f, 0.1411824f, 0.9224628f };
	static float s_ColorSpace_RGB2XYZ_Best[]         = { 0.6326696f, 0.2045558f, 0.1269946f, 0.2284569f, 0.7373523f, 0.0341908f, 0.0000000f, 0.0095142f, 0.8156958f };
	static float s_ColorSpace_RGB2XYZ_Beta[]         = { 0.6712537f, 0.1745834f, 0.1183829f, 0.3032726f, 0.6637861f, 0.0329413f, 0.0000000f, 0.0407010f, 0.7845090f };
	static float s_ColorSpace_RGB2XYZ_Bruce[]        = { 0.4674162f, 0.2944512f, 0.1886026f, 0.2410115f, 0.6835475f, 0.0754410f, 0.0219101f, 0.0736128f, 0.9933071f };
	static float s_ColorSpace_RGB2XYZ_CIERGB[]       = { 0.4887180f, 0.3106803f, 0.2006017f, 0.1762044f, 0.8129847f, 0.0108109f, 0.0000000f, 0.0102048f, 0.9897952f };
	static float s_ColorSpace_RGB2XYZ_ColorMatch[]   = { 0.5093439f, 0.3209071f, 0.1339691f, 0.2748840f, 0.6581315f, 0.0669845f, 0.0242545f, 0.1087821f, 0.6921735f };
	static float s_ColorSpace_RGB2XYZ_DonRGB4[]      = { 0.6457711f, 0.1933511f, 0.1250978f, 0.2783496f, 0.6879702f, 0.0336802f, 0.0037113f, 0.0179861f, 0.8035125f };
	static float s_ColorSpace_RGB2XYZ_ECI[]          = { 0.6502043f, 0.1780774f, 0.1359384f, 0.3202499f, 0.6020711f, 0.0776791f, 0.0000000f, 0.0678390f, 0.7573710f };
	static float s_ColorSpace_RGB2XYZ_EktaSpacePS5[] = { 0.6502043f, 0.1780774f, 0.1359384f, 0.3202499f, 0.6020711f, 0.0776791f, 0.0000000f, 0.0678390f, 0.7573710f };
	static float s_ColorSpace_RGB2XYZ_NTSC[]         = { 0.6068909f, 0.1735011f, 0.2003480f, 0.2989164f, 0.5865990f, 0.1144845f, 0.0000000f, 0.0660957f, 1.1162243f };
	static float s_ColorSpace_RGB2XYZ_PAL_SECAM[]    = { 0.4306190f, 0.3415419f, 0.1783091f, 0.2220379f, 0.7066384f, 0.0713236f, 0.0201853f, 0.1295504f, 0.9390944f };
	static float s_ColorSpace_RGB2XYZ_ProPhoto[]     = { 0.7976749f, 0.1351917f, 0.0313534f, 0.2880402f, 0.7118741f, 0.0000857f, 0.0000000f, 0.0000000f, 0.8252100f };
	static float s_ColorSpace_RGB2XYZ_SMPTE_C[]      = { 0.3935891f, 0.3652497f, 0.1916313f, 0.2124132f, 0.7010437f, 0.0865432f, 0.0187423f, 0.1119313f, 0.9581563f };
	static float s_ColorSpace_RGB2XYZ_sRGB[]         = { 0.4124564f, 0.3575761f, 0.1804375f, 0.2126729f, 0.7151522f, 0.0721750f, 0.0193339f, 0.1191920f, 0.9503041f };
	static float s_ColorSpace_RGB2XYZ_WideGamutRGB[] = { 0.7161046f, 0.1009296f, 0.1471858f, 0.2581874f, 0.7249378f, 0.0168748f, 0.0000000f, 0.0517813f, 0.7734287f };
	// TOTO find proper one
	static float s_ColorSpace_RGB2XYZ_Rec2020[]      = { 0.7161046f, 0.1009296f, 0.1471858f, 0.2581874f, 0.7249378f, 0.0168748f, 0.0000000f, 0.0517813f, 0.7734287f };
	static float* s_ColorSpace_RGB2XYZ[] = { s_ColorSpace_RGB2XYZ_AdobeRGB, s_ColorSpace_RGB2XYZ_AppleRGB, s_ColorSpace_RGB2XYZ_Best, s_ColorSpace_RGB2XYZ_Beta,
		s_ColorSpace_RGB2XYZ_Bruce, s_ColorSpace_RGB2XYZ_CIERGB, s_ColorSpace_RGB2XYZ_ColorMatch, s_ColorSpace_RGB2XYZ_DonRGB4,
		s_ColorSpace_RGB2XYZ_ECI, s_ColorSpace_RGB2XYZ_EktaSpacePS5, s_ColorSpace_RGB2XYZ_NTSC, s_ColorSpace_RGB2XYZ_PAL_SECAM,
		s_ColorSpace_RGB2XYZ_ProPhoto, s_ColorSpace_RGB2XYZ_SMPTE_C, s_ColorSpace_RGB2XYZ_sRGB, s_ColorSpace_RGB2XYZ_WideGamutRGB,
		s_ColorSpace_RGB2XYZ_Rec2020 };
	static float s_ColorSpace_Gamma[] = { 2.2f, 1.8f, 2.2f, 2.2f, 2.2f, 2.2f, 1.8f, 2.2f, 1.0f, 2.2f, 2.2f, 2.2f, 1.8f, 2.2f, 2.2f, 2.2f, 2.2f };
	// xy: { {xy}:RR, {xy}:GG, {xy}:BB }
	static ImVec2 s_ColorSpace_Primaries[][3] = {
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1500f, 0.0600f) },	// AdobeRBG
		{ ImVec2(0.6250f, 0.3400f), ImVec2(0.2800f, 0.5950f), ImVec2(0.1550f, 0.0700f) },	// AppleRGB
		{ ImVec2(0.7347f, 0.2653f), ImVec2(0.2150f, 0.7750f), ImVec2(0.1300f, 0.0350f) },	// Best
		{ ImVec2(0.6888f, 0.3112f), ImVec2(0.1986f, 0.7551f), ImVec2(0.1265f, 0.0352f) },	// Beta
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.2800f, 0.6500f), ImVec2(0.1500f, 0.0600f) },	// Bruce
		{ ImVec2(0.7350f, 0.2650f), ImVec2(0.2740f, 0.7170f), ImVec2(0.1670f, 0.0090f) },	// CIERGB
		{ ImVec2(0.6300f, 0.3400f), ImVec2(0.2950f, 0.6050f), ImVec2(0.1500f, 0.0750f) },	// ColorMatch
		{ ImVec2(0.6960f, 0.3000f), ImVec2(0.2150f, 0.7650f), ImVec2(0.1300f, 0.0350f) },	// DonRGB4
		{ ImVec2(0.6700f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1400f, 0.0800f) },	// ECI
		{ ImVec2(0.6950f, 0.3050f), ImVec2(0.2600f, 0.7000f), ImVec2(0.1100f, 0.0050f) },	// EktaSpacePS5
		{ ImVec2(0.6700f, 0.3300f), ImVec2(0.2100f, 0.7100f), ImVec2(0.1400f, 0.0800f) },	// NTSC
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.2900f, 0.6000f), ImVec2(0.1500f, 0.0600f) },	// PAL/SECAM
		{ ImVec2(0.7347f, 0.2653f), ImVec2(0.1596f, 0.8404f), ImVec2(0.0366f, 0.0001f) },	// ProPhoto
		{ ImVec2(0.6300f, 0.3400f), ImVec2(0.3100f, 0.5950f), ImVec2(0.1550f, 0.0700f) },	// SMPTE-C
		{ ImVec2(0.6400f, 0.3300f), ImVec2(0.3000f, 0.6000f), ImVec2(0.1500f, 0.0600f) },	// sRGB
		{ ImVec2(0.7350f, 0.2650f), ImVec2(0.1150f, 0.8260f), ImVec2(0.1570f, 0.0180f) },	// Wide Gamut
		{ ImVec2(0.7080f, 0.2920f), ImVec2(0.1700f, 0.7970f), ImVec2(0.1310f, 0.0460f) }	// Rec2020
	};
	static int s_ColorSpace_WhitePointIndex[] =
	{
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_E,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_C,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D65,
		ImWidgetsWhitePointChromaticPlot_D50,
		ImWidgetsWhitePointChromaticPlot_D65
	};

	//////////////////////////////////////////////////////////////////////////
	// Helpers
	//////////////////////////////////////////////////////////////////////////
	void	ScaleData(ImGuiDataType data_type, void* p_data, double value)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
			*reinterpret_cast<ImS8*>(p_data) *= static_cast<ImS8>(value);
			break;
		case ImGuiDataType_U8:
			*reinterpret_cast<ImU8*>(p_data) *= static_cast<ImU8>(value);
			break;
		case ImGuiDataType_S16:
			*reinterpret_cast<ImS16*>(p_data) *= static_cast<ImS16>(value);
			break;
		case ImGuiDataType_U16:
			*reinterpret_cast<ImU16*>(p_data) *= static_cast<ImU16>(value);
			break;
		case ImGuiDataType_S32:
			*reinterpret_cast<ImS32*>(p_data) *= static_cast<ImS32>(value);
			break;
		case ImGuiDataType_U32:
			*reinterpret_cast<ImU32*>(p_data) *= static_cast<ImU32>(value);
			break;
		case ImGuiDataType_S64:
			*reinterpret_cast<ImS64*>(p_data) *= static_cast<ImS64>(value);
			break;
		case ImGuiDataType_U64:
			*reinterpret_cast<ImU64*>(p_data) *= static_cast<ImU64>(value);
			break;
		case ImGuiDataType_Float:
			*reinterpret_cast<float*>(p_data) *= static_cast<float>(value);
			break;
		case ImGuiDataType_Double:
			*reinterpret_cast<double*>(p_data) *= value;

			break;
		}
	}
	void	ScaleData(ImGuiDataType data_type, void* p_data, ImU64 value)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
			*reinterpret_cast<ImS8*>(p_data) *= static_cast<ImS8>(value);
			break;
		case ImGuiDataType_U8:
			*reinterpret_cast<ImU8*>(p_data) *= static_cast<ImU8>(value);
			break;
		case ImGuiDataType_S16:
			*reinterpret_cast<ImS16*>(p_data) *= static_cast<ImS16>(value);
			break;
		case ImGuiDataType_U16:
			*reinterpret_cast<ImU16*>(p_data) *= static_cast<ImU16>(value);
			break;
		case ImGuiDataType_S32:
			*reinterpret_cast<ImS32*>(p_data) *= static_cast<ImS32>(value);
			break;
		case ImGuiDataType_U32:
			*reinterpret_cast<ImU32*>(p_data) *= static_cast<ImU32>(value);
			break;
		case ImGuiDataType_S64:
			*reinterpret_cast<ImS64*>(p_data) *= static_cast<ImS64>(value);
			break;
		case ImGuiDataType_U64:
			*reinterpret_cast<ImU64*>(p_data) *= static_cast<ImU64>(value);
			break;
		case ImGuiDataType_Float:
			*reinterpret_cast<float*>(p_data) *= static_cast<float>(value);
			break;
		case ImGuiDataType_Double:
			*reinterpret_cast<double*>(p_data) *= value;

			break;
		}
	}

	bool	IsNegativeScalar(ImGuiDataType data_type, ImU64* src)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(src);
			return value < 0;
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(src);
			return value < 0;
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(src);
			return value < 0l;
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(src);
			return value < 0ll;
		}
		break;
		case ImGuiDataType_U8:
		case ImGuiDataType_U16:
		case ImGuiDataType_U32:
		case ImGuiDataType_U64:
		{
			return false;
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(src);
			return value < 0.0f;
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(src);
			return value < 0.0f;
		}
		break;
		}

		return false;
	}

	bool	IsPositiveScalar(ImGuiDataType data_type, ImU64* src)
	{
		return !IsNegativeScalar(data_type, src);
	}

	//template <typename TypeSrc>
	//ImU64	SetScalar(ImGuiDataType data_type, TypeSrc src)
	//{
	//	ImU64 result;
	//	switch (data_type)
	//	{
	//	case ImGuiDataType_S8:
	//	{
	//		ImS8 value = static_cast<ImS8>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_U8:
	//	{
	//		ImU8 value = static_cast<ImU8>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_S16:
	//	{
	//		ImS16 value = static_cast<ImS16>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_U16:
	//	{
	//		ImU16 value = static_cast<ImU16>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_S32:
	//	{
	//		ImS32 value = static_cast<ImS32>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_U32:
	//	{
	//		ImU32 value = static_cast<ImU32>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_S64:
	//	{
	//		ImS64 value = static_cast<ImS64>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_U64:
	//	{
	//		ImU64 value = static_cast<ImU64>(src);
	//		result = static_cast<ImU64>(value);
	//	}
	//	break;
	//	case ImGuiDataType_Float:
	//	{
	//		float value = static_cast<float>(src);
	//		result = *reinterpret_cast<ImU64*>(&value);
	//	}
	//	break;
	//	case ImGuiDataType_Double:
	//	{
	//		double value = static_cast<double>(src);
	//		result = *reinterpret_cast<ImU64*>(&value);
	//	}
	//	break;
	//	}

	//	return result;
	//}

	void	EqualScalar(ImGuiDataType data_type, ImU64* p_target, ImU64* p_source)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
			*reinterpret_cast<ImS8*>(p_target) = *reinterpret_cast<ImS8*>(p_source);
			break;
		case ImGuiDataType_U8:
			*reinterpret_cast<ImU8*>(p_target) = *reinterpret_cast<ImU8*>(p_source);
			break;
		case ImGuiDataType_S16:
			*reinterpret_cast<ImS16*>(p_target) = *reinterpret_cast<ImS16*>(p_source);
			break;
		case ImGuiDataType_U16:
			*reinterpret_cast<ImU16*>(p_target) = *reinterpret_cast<ImU16*>(p_source);
			break;
		case ImGuiDataType_S32:
			*reinterpret_cast<ImS32*>(p_target) = *reinterpret_cast<ImS32*>(p_source);
			break;
		case ImGuiDataType_U32:
			*reinterpret_cast<ImU64*>(p_target) = *reinterpret_cast<ImU32*>(p_source);
			break;
		case ImGuiDataType_S64:
			*reinterpret_cast<ImS64*>(p_target) = *reinterpret_cast<ImS64*>(p_source);
			break;
		case ImGuiDataType_U64:
			*reinterpret_cast<ImU64*>(p_target) = *reinterpret_cast<ImU64*>(p_source);
			break;
		case ImGuiDataType_Float:
			*reinterpret_cast<float*>(p_target) = *reinterpret_cast<float*>(p_source);
			break;
		case ImGuiDataType_Double:
			*reinterpret_cast<double*>(p_target) = *reinterpret_cast<double*>(p_source);
			break;
		}
	}

	void	SetScalarIndirect( ImGuiDataType data_type, void* p_target, int idx, ImU64* p_source )
	{
		switch ( data_type )
		{
		case ImGuiDataType_S8:
			reinterpret_cast< ImS8* >( p_target )[ idx ] = *reinterpret_cast< ImS8* >( p_source );
			break;
		case ImGuiDataType_U8:
			reinterpret_cast< ImU8* >( p_target )[ idx ] = *reinterpret_cast< ImU8* >( p_source );
			break;
		case ImGuiDataType_S16:
			reinterpret_cast< ImS16* >( p_target )[ idx ] = *reinterpret_cast< ImS16* >( p_source );
			break;
		case ImGuiDataType_U16:
			reinterpret_cast< ImU16* >( p_target )[ idx ] = *reinterpret_cast< ImU16* >( p_source );
			break;
		case ImGuiDataType_S32:
			reinterpret_cast< ImS32* >( p_target )[ idx ] = *reinterpret_cast< ImS32* >( p_source );
			break;
		case ImGuiDataType_U32:
			reinterpret_cast< ImU64* >( p_target )[ idx ] = *reinterpret_cast< ImU32* >( p_source );
			break;
		case ImGuiDataType_S64:
			reinterpret_cast< ImS64* >( p_target )[ idx ] = *reinterpret_cast< ImS64* >( p_source );
			break;
		case ImGuiDataType_U64:
			reinterpret_cast< ImU64* >( p_target )[ idx ] = *reinterpret_cast< ImU64* >( p_source );
			break;
		case ImGuiDataType_Float:
			reinterpret_cast< float* >( p_target )[ idx ] = *reinterpret_cast< float* >( p_source );
			break;
		case ImGuiDataType_Double:
			reinterpret_cast< double* >( p_target )[ idx ] = *reinterpret_cast< double* >( p_source );
			break;
		}
	}

	float	ScalarToFloat(ImGuiDataType data_type, ImU64* p_source)
	{
		switch ( data_type )
		{
		case ImGuiDataType_S8:
			return static_cast< float >( *reinterpret_cast< ImS8* >( p_source ) );
		case ImGuiDataType_U8:
			return static_cast< float >( *reinterpret_cast< ImU8* >( p_source ) );
		case ImGuiDataType_S16:
			return static_cast< float >( *reinterpret_cast< ImS16* >( p_source ) );
		case ImGuiDataType_U16:
			return static_cast< float >( *reinterpret_cast< ImU16* >( p_source ) );
		case ImGuiDataType_S32:
			return static_cast< float >( *reinterpret_cast< ImS32* >( p_source ) );
		case ImGuiDataType_U32:
			return static_cast< float >( *reinterpret_cast< ImU32* >( p_source ) );
		case ImGuiDataType_S64:
			return static_cast< float >( *reinterpret_cast< ImS64* >( p_source ) );
		case ImGuiDataType_U64:
			return static_cast< float >( *reinterpret_cast< ImU64* >( p_source ) );
		case ImGuiDataType_Float:
			return static_cast< float >( *reinterpret_cast< float* >( p_source ) );
		case ImGuiDataType_Double:
			return static_cast< float >( *reinterpret_cast< double* >( p_source ) );
		}

		return 0.0f;
	}

	float	ScalarIndirectToFloat( ImGuiDataType data_type, void* p_source, int idx )
	{
		switch ( data_type )
		{
		case ImGuiDataType_S8:
			return static_cast< float >( reinterpret_cast< ImS8* >( p_source )[ idx ] );
		case ImGuiDataType_U8:
			return static_cast< float >( reinterpret_cast< ImU8* >( p_source )[ idx ] );
		case ImGuiDataType_S16:
			return static_cast< float >( reinterpret_cast< ImS16* >( p_source )[ idx ] );
		case ImGuiDataType_U16:
			return static_cast< float >( reinterpret_cast< ImU16* >( p_source )[ idx ] );
		case ImGuiDataType_S32:
			return static_cast< float >( reinterpret_cast< ImS32* >( p_source )[ idx ] );
		case ImGuiDataType_U32:
			return static_cast< float >( reinterpret_cast< ImU32* >( p_source )[ idx ] );
		case ImGuiDataType_S64:
			return static_cast< float >( reinterpret_cast< ImS64* >( p_source )[ idx ] );
		case ImGuiDataType_U64:
			return static_cast< float >( reinterpret_cast< ImU64* >( p_source )[ idx ] );
		case ImGuiDataType_Float:
			return static_cast< float >( reinterpret_cast< float* >( p_source )[ idx ] );
		case ImGuiDataType_Double:
			return static_cast< float >( reinterpret_cast< double* >( p_source )[ idx ] );
		}

		return 0.0f;
	}

	ImU64	ScalarIndirectToScalar( ImGuiDataType data_type, void* p_source, int idx )
	{
		switch ( data_type )
		{
		case ImGuiDataType_S8:
			return static_cast< ImU64 >( reinterpret_cast< ImS8* >( p_source )[ idx ] );
		case ImGuiDataType_U8:
			return static_cast< ImU64 >( reinterpret_cast< ImU8* >( p_source )[ idx ] );
		case ImGuiDataType_S16:
			return static_cast< ImU64 >( reinterpret_cast< ImS16* >( p_source )[ idx ] );
		case ImGuiDataType_U16:
			return static_cast< ImU64 >( reinterpret_cast< ImU16* >( p_source )[ idx ] );
		case ImGuiDataType_S32:
			return static_cast< ImU64 >( reinterpret_cast< ImS32* >( p_source )[ idx ] );
		case ImGuiDataType_U32:
			return static_cast< ImU64 >( reinterpret_cast< ImU32* >( p_source )[ idx ] );
		case ImGuiDataType_S64:
			return static_cast< ImU64 >( reinterpret_cast< ImS64* >( p_source )[ idx ] );
		case ImGuiDataType_U64:
			return static_cast< ImU64 >( reinterpret_cast< ImU64* >( p_source )[ idx ] );
		case ImGuiDataType_Float:
			return static_cast< ImU64 >( reinterpret_cast< float* >( p_source )[ idx ] );
		case ImGuiDataType_Double:
			return static_cast< ImU64 >( reinterpret_cast< double* >( p_source )[ idx ] );
		}

		return ImU64(-1);
	}

	ImU64	FloatToScalar(ImGuiDataType data_type, float f_value)
	{
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = static_cast<ImS8>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U8:
		{
			ImU8 value = static_cast<ImU8>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_S16:
		{
			ImS16 value = static_cast<ImS16>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U16:
		{
			ImU16 value = static_cast<ImU16>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_S32:
		{
			ImS32 value = static_cast<ImS32>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U32:
		{
			ImU32 value = static_cast<ImU32>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_S64:
		{
			ImS64 value = static_cast<ImS64>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_U64:
		{
			ImU64 value = static_cast<ImU64>(f_value);
			return static_cast<ImU64>(value);
		}
		case ImGuiDataType_Float:
		{
			float value = f_value;
			return *reinterpret_cast<ImU64*>(&value);
		}
		case ImGuiDataType_Double:
		{
			double value = static_cast<double>(f_value);
			return *reinterpret_cast<ImU64*>(&value);
		}
		}

		return ImU64();
	}

	ImU64	AddScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) + *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) + *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) + *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) + *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) + *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) + *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) + *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) + *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) + *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) + *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	SubScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result = 0;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) - *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) - *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) - *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) - *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) - *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) - *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) - *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) - *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) - *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) - *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	MulScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) * *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) * *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) * *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) * *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) * *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) * *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) * *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) * *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) * *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) * *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	DivScalar(ImGuiDataType data_type, void* p_a, void* p_b)
	{
		ImU64 result;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = *reinterpret_cast<ImS8*>(p_a) / *static_cast<ImS8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = *reinterpret_cast<ImU8*>(p_a) / *static_cast<ImU8*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = *reinterpret_cast<ImS16*>(p_a) / *static_cast<ImS16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = *reinterpret_cast<ImU16*>(p_a) / *static_cast<ImU16*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = *reinterpret_cast<ImS32*>(p_a) / *static_cast<ImS32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = *reinterpret_cast<ImU32*>(p_a) / *static_cast<ImU32*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = *reinterpret_cast<ImS64*>(p_a) / *static_cast<ImS64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = *reinterpret_cast<ImU64*>(p_a) / *static_cast<ImU64*>(p_b);
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = *reinterpret_cast<float*>(p_a) / *static_cast<float*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = *reinterpret_cast<double*>(p_a) / *static_cast<double*>(p_b);
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	ClampScalar(ImGuiDataType data_type, void* p_value, void* p_min, void* p_max)
	{
		ImU64 result = 0;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = ImClamp(*reinterpret_cast<ImS8*>(p_value), *static_cast<ImS8*>(p_min), *static_cast<ImS8*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = ImClamp(*reinterpret_cast<ImU8*>(p_value), *static_cast<ImU8*>(p_min), *static_cast<ImU8*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = ImClamp(*reinterpret_cast<ImS16*>(p_value), *static_cast<ImS16*>(p_min), *static_cast<ImS16*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = ImClamp(*reinterpret_cast<ImU16*>(p_value), *static_cast<ImU16*>(p_min), *static_cast<ImU16*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = ImClamp(*reinterpret_cast<ImS32*>(p_value), *static_cast<ImS32*>(p_min), *static_cast<ImS32*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = ImClamp(*reinterpret_cast<ImU32*>(p_value), *static_cast<ImU32*>(p_min), *static_cast<ImU32*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = ImClamp(*reinterpret_cast<ImS64*>(p_value), *static_cast<ImS64*>(p_min), *static_cast<ImS64*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = ImClamp(*reinterpret_cast<ImU64*>(p_value), *static_cast<ImU64*>(p_min), *static_cast<ImU64*>(p_max));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = ImClamp(*reinterpret_cast<float*>(p_value), *static_cast<float*>(p_min), *static_cast<float*>(p_max));
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = ImClamp(*reinterpret_cast<double*>(p_value), *static_cast<double*>(p_min), *static_cast<double*>(p_max));
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	ImU64	Normalize01(ImGuiDataType data_type, void* p_value, void const* p_min, void const* p_max)
	{
		ImU64 result = 0;
		switch (data_type)
		{
		case ImGuiDataType_S8:
		{
			ImS8 value = (*reinterpret_cast<ImS8*>(p_value) - *static_cast<ImS8 const*>(p_min)) / (*static_cast<ImS8 const*>(p_max) - *static_cast<ImS8 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U8:
		{
			ImU8 value = (*reinterpret_cast<ImU8*>(p_value) - *static_cast<ImU8 const*>(p_min)) / (*static_cast<ImU8 const*>(p_max) - *static_cast<ImU8 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S16:
		{
			ImS16 value = (*reinterpret_cast<ImS16*>(p_value) - *static_cast<ImS16 const*>(p_min)) / (*static_cast<ImS16 const*>(p_max) - *static_cast<ImS16 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U16:
		{
			ImU16 value = (*reinterpret_cast<ImU16*>(p_value) - *static_cast<ImU16 const*>(p_min)) / (*static_cast<ImU16 const*>(p_max) - *static_cast<ImU16 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S32:
		{
			ImS32 value = (*reinterpret_cast<ImS32*>(p_value) - *static_cast<ImS32 const*>(p_min)) / (*static_cast<ImS32 const*>(p_max) - *static_cast<ImS32 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U32:
		{
			ImU32 value = (*reinterpret_cast<ImU32*>(p_value) - *static_cast<ImU32 const*>(p_min)) / (*static_cast<ImU32 const*>(p_max) - *static_cast<ImU32 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_S64:
		{
			ImS64 value = (*reinterpret_cast<ImS64*>(p_value) - *static_cast<ImS64 const*>(p_min)) / (*static_cast<ImS64 const*>(p_max) - *static_cast<ImS64 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_U64:
		{
			ImU64 value = (*reinterpret_cast<ImU64*>(p_value) - *static_cast<ImU64 const*>(p_min)) / (*static_cast<ImU64 const*>(p_max) - *static_cast<ImU64 const*>(p_min));
			result = static_cast<ImU64>(value);
		}
		break;
		case ImGuiDataType_Float:
		{
			float value = (*reinterpret_cast<float*>(p_value) - *static_cast<float const*>(p_min)) / (*static_cast<float const*>(p_max) - *static_cast<float const*>(p_min));
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		case ImGuiDataType_Double:
		{
			double value = (*reinterpret_cast<double*>(p_value) - *static_cast<double const*>(p_min)) / (*static_cast<double const*>(p_max) - *static_cast<double const*>(p_min));
			result = *reinterpret_cast<ImU64*>(&value);
		}
		break;
		}

		return result;
	}

	float	Dot3(float x0, float x1, float x2, float* vec3)
	{
		return x0 * vec3[0] + x1 * vec3[1] + x2 * vec3[2];
	}

	void	Mat33MulV(float* z0, float* z1, float* z2, float x, float y, float z, float* mat)
	{
		*z0 = Dot3(x, y, z, &mat[0]);
		*z1 = Dot3(x, y, z, &mat[3]);
		*z2 = Dot3(x, y, z, &mat[6]);
	}

//	void		MemoryString(std::string& sResult, ImU64 const uMemoryByte)
//	{
//		if (uMemoryByte < ImWidgets_Kibi)
//		{
//			sResult = std::to_string(static_cast<float>(uMemoryByte)) + " B";
//		}
//		else if (uMemoryByte < ImWidgets_Mibi)
//		{
//			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Kibi)) + " KiB";
//		}
//		else if (uMemoryByte < ImWidgets_Gibi)
//		{
//			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Mibi)) + " MiB";
//		}
//		else if (uMemoryByte < ImWidgets_Tebi)
//		{
//			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Gibi)) + " GiB";
//		}
//		else if (uMemoryByte < ImWidgets_Pebi)
//		{
//			sResult = std::to_string(static_cast<float>(uMemoryByte) / static_cast<float>(ImWidgets_Tebi)) + " TiB";
//		}
//	}
//
//	void		TimeString(std::string& sResult, ImU64 const uNanoseconds)
//	{
//		std::chrono::nanoseconds oDuration( uNanoseconds );
//
//		typedef std::chrono::duration< ImU64, std::ratio_multiply< std::chrono::hours::period, std::ratio< 8 > >::type > Days; // UTC: +8:00
//
//		Days oDays			= std::chrono::duration_cast< Days >( oDuration );
//		oDuration -= oDays;
//		auto oHours			= std::chrono::duration_cast< std::chrono::hours >( oDuration );
//		oDuration -= oHours;
//		auto oMinutes		= std::chrono::duration_cast< std::chrono::minutes >( oDuration );
//		oDuration -= oMinutes;
//		auto oSeconds		= std::chrono::duration_cast< std::chrono::seconds >( oDuration );
//		oDuration -= oSeconds;
//		auto oMilliseconds	= std::chrono::duration_cast< std::chrono::milliseconds >( oDuration );
//		oDuration -= oMilliseconds;
//		auto oMicroseconds	= std::chrono::duration_cast< std::chrono::microseconds >( oDuration );
//		oDuration -= oMicroseconds;
//		auto oNanoseconds	= std::chrono::duration_cast< std::chrono::nanoseconds >( oDuration );
//
//		ImU64 const uNanoSecondsCountRaw	= oNanoseconds.count();
//		ImU64 const uNanoSecondsCount		= uNanoSecondsCountRaw <= 100ull ? 0ull : uNanoSecondsCountRaw;
//
//		sResult.clear();
//		if ( oDays.count() > 0 )
//		{
//			sResult =	std::to_string( oDays.count() )			+ " d : " +
//						std::to_string( oHours.count() )		+ " h : " +
//						std::to_string( oMinutes.count() )		+ " min : " +
//						std::to_string( oSeconds.count() )		+ " s : " +
//						std::to_string( oMilliseconds.count() )	+ " ms : " +
//						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
//						std::to_string( oMicroseconds.count() ) + " us";//: " +
//						//std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//		else if ( oHours.count() > 0 )
//		{
//			sResult =	std::to_string( oHours.count() )		+ " h : " +
//						std::to_string( oMinutes.count() )		+ " min : " +
//						std::to_string( oSeconds.count() )		+ " s : " +
//						std::to_string( oMilliseconds.count() )	+ " ms : " +
//						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
//						std::to_string( oMicroseconds.count() ) + " us";//: " +
//						//std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//		else if ( oMinutes.count() > 0 )
//		{
//			sResult =	std::to_string( oMinutes.count() )		+ " min : " +
//						std::to_string( oSeconds.count() )		+ " s : " +
//						std::to_string( oMilliseconds.count() )	+ " ms : " +
//						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
//						std::to_string( oMicroseconds.count() ) + " us";//: " +
//						//std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//		else if ( oSeconds.count() > 0 )
//		{
//			sResult =	std::to_string( oSeconds.count() )		+ " s : " +
//						std::to_string( oMilliseconds.count() )	+ " ms : " +
//						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
//						std::to_string( oMicroseconds.count() ) + " us";//: " +
//						//std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//		else if ( oMilliseconds.count() > 0 )
//		{
//			sResult =	std::to_string( oMilliseconds.count() )	+ " ms : " +
//						//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
//						std::to_string( oMicroseconds.count() ) + " us";//: " +
//						//std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//		else if ( oMicroseconds.count() > 0 )
//		{
//			sResult =	//std::to_string( oMicroseconds.count() ) + " \u00B5s : " +
//						std::to_string( oMicroseconds.count() ) + " us";//: " +
//						//std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//		else //if ( oNanoseconds.count() > 0 )
//		{
//			sResult =	std::to_string( uNanoSecondsCount )		+ " ns";
//		}
//	}

	float Dist2(ImVec2 const v, ImVec2 const w)
	{
		//return Sqr(v.x - w.x) + Sqr(v.y - w.y);
		return ImLengthSqr(v - w);
	}
	float DistOnSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w)
	{
		float l2 = Dist2(v, w);
		//if (l2 == 0.0f)
		//	return 0.0f;

		float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;

		return ImSaturate(t) * Dist2(w, v);
	}
	float DistToSegmentSqr(ImVec2 const p, ImVec2 const v, ImVec2 const w)
	{
		//float l2 = Dist2(v, w);
		////if (l2 == 0.0f)
		////	return Dist2(p, v);
		//
		//float t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
		//t = ImSaturate(t);
		//
		//return Dist2(p, ImVec2(v.x + t * (w.x - v.x),
		//					   v.y + t * (w.y - v.y)));

		float const lDx = v.x - w.x;
		float const lDy = v.y - w.y;

		float const dx = v.x - p.x;
		float const dy = v.y - p.y;

		float const l2 = ImSqrt(ImLengthSqr(w - v));

		return ImAbs(lDx * dy - lDy * dx) / l2;
	}
	float Side(ImVec2 const src, ImVec2 const tgt, ImVec2 const pts)
	{
		ImVec2 vDir = tgt - src;
		ImVec2 vVec = pts - src;

		float zCross = vDir.x * vVec.y - vDir.y * vVec.x;

		return zCross >= 0.0f ? 1.0f : -1.0f;
	}
	ImVec2 Saturatev(ImVec2 const v)
	{
		return ImVec2(ImSaturate(v.x), ImSaturate(v.y));
	}
	ImVec2 Clampv(ImVec2 const v, ImVec2 const min, ImVec2 const max)
	{
		return ImVec2(ImClamp(v.x, min.x, max.x), ImClamp(v.y, min.y, max.y));
	}
	float Rescale01(float const x, float const min, float const max)
	{
		return (x - min) / (max - min);
	}
	ImVec2 Rescale01v(ImVec2 const v, ImVec2 const min, ImVec2 const max)
	{
		return ImVec2(Rescale01(v.x, min.x, max.x), Rescale01(v.y, min.y, max.y));
	}
	float Rescale(float const x, float const min, float const max, float const newMin, float const newMax)
	{
		return Rescale01(x, min, max) * (newMax - newMin) + newMin;
	}
	ImVec2 Rescalev(ImVec2 const x, ImVec2 const min, ImVec2 const max, ImVec2 const newMin, ImVec2 const newMax)
	{
		ImVec2 const vNorm = Rescale01v(x, min, max);
		return ImVec2(vNorm.x * (newMax.x - newMin.x) + newMin.x, vNorm.y * (newMax.y - newMin.y) + newMin.y);
	}
	float Sign(float x)
	{
		return x < 0.0f ? -1.0f : 1.0f;
	}
	float	ImLinearSample( float t, float* buffer, int count )
	{
#if 0
		float const width = ( float )( count - 1 );

		float tx = ScaleFromNormalized( t, 0.0f, width );

		float i0 = ImFloor( tx );
		float i1 = ImCeil( tx );

		float t0 = i0 / width;
		float t1 = i1 / width;

		float ti;
		if ( t0 != t1 )
			ti = Normalize01( t, t0, t1 );
		else
			ti = 1.0f;

		return ImLerp( buffer[ ( int )i0 ], buffer[ ( int )i1 ], ti );
#else
		float const width = ( float )( count - 1 );

		float const i0 = ImFloor( t * width );
		float const i1 = ImCeil( t * width );

		float ti;
		if ( i0 != i1 )
			ti = ( t * width - i0 ) / ( i1 - i0 );
		else
			ti = 1.0f;

		return ImLerp( buffer[ ( int )i0 ], buffer[ ( int )i1 ], ti );
#endif
	}

	void          ColorConvertsRGBtosRGB( float r, float g, float b, float& out_r, float& out_g, float& out_b )
	{
		out_r = r;
		out_g = g;
		out_b = b;
	}
	void          ColorConvertRGBtoLinear( float r, float g, float b, float& out_r, float& out_g, float& out_b )
	{
		out_r = ImsRGBToLinear( r );
		out_g = ImsRGBToLinear( g );
		out_b = ImsRGBToLinear( b );
		out_r = ImSaturate( out_r );
		out_g = ImSaturate( out_g );
		out_b = ImSaturate( out_b );
	}
	void          ColorConvertLineartoRGB( float r, float g, float b, float& out_r, float& out_g, float& out_b )
	{
		out_r = ImLinearTosRGB( r );
		out_g = ImLinearTosRGB( g );
		out_b = ImLinearTosRGB( b );
		out_r = ImSaturate( out_r );
		out_g = ImSaturate( out_g );
		out_b = ImSaturate( out_b );
	}
	void          ColorConvertRGBtoOKLAB( float r, float g, float b, float& out_L, float& out_a, float& out_b )
	{
		r = ImsRGBToLinear( r );
		g = ImsRGBToLinear( g );
		b = ImsRGBToLinear( b );
		float l = 0.4122214708f * r + 0.5363325363f * g + 0.0514459929f * b;
		float m = 0.2119034982f * r + 0.6806995451f * g + 0.1073969566f * b;
		float s = 0.0883024619f * r + 0.2817188376f * g + 0.6299787005f * b;
		l = ImCbrt( l );
		m = ImCbrt( m );
		s = ImCbrt( s );
		out_L = l * +0.2104542553f + m * +0.7936177850f + s * -0.0040720468f;
		out_a = l * +1.9779984951f + m * -2.4285922050f + s * +0.4505937099f;
		out_b = l * +0.0259040371f + m * +0.7827717662f + s * -0.8086757660f;
	}
	void          ColorConvertOKLABtoRGB( float L, float a, float b, float& out_r, float& out_g, float& out_b )
	{
		float l = L + a * +0.3963377774f + b * +0.2158037573f;
		float m = L + a * -0.1055613458f + b * -0.0638541728f;
		float s = L + a * -0.0894841775f + b * -1.2914855480f;
		l = l * l * l;
		m = m * m * m;
		s = s * s * s;
		out_r = l * +4.0767416621f + m * -3.3077115913f + s * +0.2309699292f;
		out_g = l * -1.2684380046f + m * +2.6097574011f + s * -0.3413193965f;
		out_b = l * -0.0041960863f + m * -0.7034186147f + s * +1.7076147010f;
		out_r = ImLinearTosRGB( out_r );
		out_g = ImLinearTosRGB( out_g );
		out_b = ImLinearTosRGB( out_b );
	}
	void          ColorConvertOKLCHtoOKLAB( float L, float c, float h, float& out_L, float& out_a, float& out_b )
	{
		out_L = L;
		out_a = c * ImCos( h * 2.0f * IM_PI );
		out_b = c * ImSin( h * 2.0f * IM_PI );
	}
	void          ColorConvertOKLABtoOKLCH( float L, float a, float b, float& out_L, float& out_c, float& out_h )
	{
		out_L = L;
		out_c = ImSqrt( a * a + b * b );
		out_h = ImAtan2( b, a );
		if ( out_h < 0.0f )
		{
			out_h += 2.0f * IM_PI;
		}
		out_h /= 2.0f * IM_PI;
		out_h = ImSaturate( out_h );
	}
	void          ColorConvertsRGBtoOKLCH( float r, float g, float b, float& out_L, float& out_c, float& out_h )
	{
		float lL, la, lb;
		ColorConvertRGBtoOKLAB( r, g, b, lL, la, lb );
		ColorConvertOKLABtoOKLCH( lL, la, lb, out_L, out_c, out_h );
	}
	void          ColorConvertOKLCHtosRGB( float L, float c, float h, float& out_r, float& out_g, float& out_b )
	{
		float lL, la, lb;
		ColorConvertOKLCHtoOKLAB( L, c, h, lL, la, lb );
		ColorConvertOKLABtoRGB( lL, la, lb, out_r, out_g, out_b );
	}

	ImU32	KelvinTemperatureTosRGBColors( float temperature )
	{
		float _r = ImFunctionFromData( temperature, s_min_kelvin_temp, s_max_kelvin_temp, s_kelvin_sRGB_Colors_Red,   s_kelvin_temp_count );
		float _g = ImFunctionFromData( temperature, s_min_kelvin_temp, s_max_kelvin_temp, s_kelvin_sRGB_Colors_Green, s_kelvin_temp_count );
		float _b = ImFunctionFromData( temperature, s_min_kelvin_temp, s_max_kelvin_temp, s_kelvin_sRGB_Colors_Blue,  s_kelvin_temp_count );

		ImU8 r = ( ImU8 )ImRound( _r );
		ImU8 g = ( ImU8 )ImRound( _g );
		ImU8 b = ( ImU8 )ImRound( _b );

		return IM_COL32( r, g, b, 255 );
	}

	ImU32	ImColorFrom_xyz( float x, float y, float z, float* xyzToRGB, float gamma )
	{
		float r, g, b;
		float maxValue;
		Mat33MulV( &r, &g, &b, x, y, z, xyzToRGB );
		maxValue = ImMax( r, ImMax( g, b ) );
		if ( maxValue > 0.0f )
		{
			r /= maxValue;
			g /= maxValue;
			b /= maxValue;
		}
		r = ImSaturate( r );
		g = ImSaturate( g );
		b = ImSaturate( b );

		r = ImPow( r, gamma );
		g = ImPow( g, gamma );
		b = ImPow( b, gamma );

		return IM_COL32( r * 255, g * 255, b * 255, 255 );
	}

	//void ColorConvertHWBtoRGB( float h, float w, float bk, float& r, float& g, float& b )
	//{
	//	/**
 //* @param {number} hue -  Hue as degrees 0..360
 //* @param {number} white -  Whiteness in reference range [0,100]
 //* @param {number} black -  Blackness in reference range [0,100]
 //* @return {number[]} Array of RGB components 0..1
 //*/
	//	/*function hwbToRgb( hue, white, black )
	//	{
	//		white /= 100;
	//		black /= 100;
	//		if ( white + black >= 1 )
	//		{
	//			let gray = white / ( white + black );
	//			return[ gray, gray, gray ];
	//		}
	//		let rgb = hslToRgb( hue, 100, 50 );
	//		for ( let i = 0; i < 3; i++ )
	//		{
	//			rgb[ i ] *= ( 1 - white - black );
	//			rgb[ i ] += white;
	//		}
	//		return rgb;
	//	}*/
	//	if ( w + bk >= 1.0f )
	//	{
	//		float grey = w / ( w + bk );
	//		r = grey;
	//		g = grey;
	//		b = grey;
	//	}
	//}

	IMGUI_API ImU32 ImColorBlendsRGB( ImU32 col0, ImU32 col1, float t )
	{
		ImVec4 v0 = ImGui::ColorConvertU32ToFloat4( col0 );
		ImVec4 v1 = ImGui::ColorConvertU32ToFloat4( col1 );

		ImVec4 o = ImLerp( v0, v1, t );

		return ImGui::GetColorU32( o );
	}

	//-----------------------------------------------------------------------------
	// [SECTION] ImTriangulator, ImDrawList concave polygon fill
	// COPY/PASTED FROM IMGUI_DRAW.CPP
	//-----------------------------------------------------------------------------

	enum ImTriangulatorNodeType0
	{
		ImTriangulatorNodeType_Convex,
		ImTriangulatorNodeType_Ear,
		ImTriangulatorNodeType_Reflex
	};

	struct ImTriangulatorNode0
	{
		ImTriangulatorNodeType0  Type;
		int                     Index;
		ImVec2                  Pos;
		ImTriangulatorNode0* Next;
		ImTriangulatorNode0* Prev;

		void    Unlink()
		{
			Next->Prev = Prev; Prev->Next = Next;
		}
	};

	struct ImTriangulatorNodeSpan0
	{
		ImTriangulatorNode0** Data = NULL;
		int                     Size = 0;

		void    push_back( ImTriangulatorNode0* node )
		{
			Data[ Size++ ] = node;
		}
		void    find_erase_unsorted( int idx )
		{
			for ( int i = Size - 1; i >= 0; i-- ) if ( Data[ i ]->Index == idx )
			{
				Data[ i ] = Data[ Size - 1 ]; Size--; return;
			}
		}
	};

	struct ImTriangulator0
	{
		static int EstimateTriangleCount( int points_count )
		{
			return ( points_count < 3 ) ? 0 : points_count - 2;
		}
		static int EstimateScratchBufferSize( int points_count )
		{
			return sizeof( ImTriangulatorNode0 ) * points_count + sizeof( ImTriangulatorNode0* ) * points_count * 2;
		}

		void    Init( const ImVec2* points, int points_count, void* scratch_buffer );
		void    GetNextTriangle( unsigned int out_triangle[ 3 ] );     // Return relative indexes for next triangle

		// Internal functions
		void    BuildNodes( const ImVec2* points, int points_count );
		void    BuildReflexes();
		void    BuildEars();
		void    FlipNodeList();
		bool    IsEar( int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2 ) const;
		void    ReclassifyNode( ImTriangulatorNode0* node );

		// Internal members
		int                     _TrianglesLeft = 0;
		ImTriangulatorNode0* _Nodes = NULL;
		ImTriangulatorNodeSpan0  _Ears;
		ImTriangulatorNodeSpan0  _Reflexes;
	};

	// Distribute storage for nodes, ears and reflexes.
	// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer
	// (this would require first building reflexes to bail to convex if empty, without even building nodes)
	void ImTriangulator0::Init( const ImVec2* points, int points_count, void* scratch_buffer )
	{
		IM_ASSERT( scratch_buffer != NULL && points_count >= 3 );
		_TrianglesLeft = EstimateTriangleCount( points_count );
		_Nodes = ( ImTriangulatorNode0* )scratch_buffer;                          // points_count x Node
		_Ears.Data = ( ImTriangulatorNode0** )( _Nodes + points_count );                // points_count x Node*
		_Reflexes.Data = ( ImTriangulatorNode0** )( _Nodes + points_count ) + points_count; // points_count x Node*
		BuildNodes( points, points_count );
		BuildReflexes();
		BuildEars();
	}

	void ImTriangulator0::BuildNodes( const ImVec2* points, int points_count )
	{
		for ( int i = 0; i < points_count; i++ )
		{
			_Nodes[ i ].Type = ImTriangulatorNodeType_Convex;
			_Nodes[ i ].Index = i;
			_Nodes[ i ].Pos = points[ i ];
			_Nodes[ i ].Next = _Nodes + i + 1;
			_Nodes[ i ].Prev = _Nodes + i - 1;
		}
		_Nodes[ 0 ].Prev = _Nodes + points_count - 1;
		_Nodes[ points_count - 1 ].Next = _Nodes;
	}

	void ImTriangulator0::BuildReflexes()
	{
		ImTriangulatorNode0* n1 = _Nodes;
		for ( int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next )
		{
			if ( ImTriangleIsClockwise( n1->Prev->Pos, n1->Pos, n1->Next->Pos ) )
				continue;
			n1->Type = ImTriangulatorNodeType_Reflex;
			_Reflexes.push_back( n1 );
		}
	}

	void ImTriangulator0::BuildEars()
	{
		ImTriangulatorNode0* n1 = _Nodes;
		for ( int i = _TrianglesLeft; i >= 0; i--, n1 = n1->Next )
		{
			if ( n1->Type != ImTriangulatorNodeType_Convex )
				continue;
			if ( !IsEar( n1->Prev->Index, n1->Index, n1->Next->Index, n1->Prev->Pos, n1->Pos, n1->Next->Pos ) )
				continue;
			n1->Type = ImTriangulatorNodeType_Ear;
			_Ears.push_back( n1 );
		}
	}

	void ImTriangulator0::GetNextTriangle( unsigned int out_triangle[ 3 ] )
	{
		if ( _Ears.Size == 0 )
		{
			FlipNodeList();

			ImTriangulatorNode0* node = _Nodes;
			for ( int i = _TrianglesLeft; i >= 0; i--, node = node->Next )
				node->Type = ImTriangulatorNodeType_Convex;
			_Reflexes.Size = 0;
			BuildReflexes();
			BuildEars();

			// If we still don't have ears, it means geometry is degenerated.
			if ( _Ears.Size == 0 )
			{
				// Return first triangle available, mimicking the behavior of convex fill.
				IM_ASSERT( _TrianglesLeft > 0 ); // Geometry is degenerated
				_Ears.Data[ 0 ] = _Nodes;
				_Ears.Size = 1;
			}
		}

		ImTriangulatorNode0* ear = _Ears.Data[ --_Ears.Size ];
		out_triangle[ 0 ] = ear->Prev->Index;
		out_triangle[ 1 ] = ear->Index;
		out_triangle[ 2 ] = ear->Next->Index;

		ear->Unlink();
		if ( ear == _Nodes )
			_Nodes = ear->Next;

		ReclassifyNode( ear->Prev );
		ReclassifyNode( ear->Next );
		_TrianglesLeft--;
	}

	void ImTriangulator0::FlipNodeList()
	{
		ImTriangulatorNode0* prev = _Nodes;
		ImTriangulatorNode0* temp = _Nodes;
		ImTriangulatorNode0* current = _Nodes->Next;
		prev->Next = prev;
		prev->Prev = prev;
		while ( current != _Nodes )
		{
			temp = current->Next;

			current->Next = prev;
			prev->Prev = current;
			_Nodes->Next = current;
			current->Prev = _Nodes;

			prev = current;
			current = temp;
		}
		_Nodes = prev;
	}

	// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)
	bool ImTriangulator0::IsEar( int i0, int i1, int i2, const ImVec2& v0, const ImVec2& v1, const ImVec2& v2 ) const
	{
		ImTriangulatorNode0** p_end = _Reflexes.Data + _Reflexes.Size;
		for ( ImTriangulatorNode0** p = _Reflexes.Data; p < p_end; p++ )
		{
			ImTriangulatorNode0* reflex = *p;
			if ( reflex->Index != i0 && reflex->Index != i1 && reflex->Index != i2 )
				if ( ImTriangleContainsPoint( v0, v1, v2, reflex->Pos ) )
					return false;
		}
		return true;
	}

	void ImTriangulator0::ReclassifyNode( ImTriangulatorNode0* n1 )
	{
		// Classify node
		ImTriangulatorNodeType0 type;
		const ImTriangulatorNode0* n0 = n1->Prev;
		const ImTriangulatorNode0* n2 = n1->Next;
		if ( !ImTriangleIsClockwise( n0->Pos, n1->Pos, n2->Pos ) )
			type = ImTriangulatorNodeType_Reflex;
		else if ( IsEar( n0->Index, n1->Index, n2->Index, n0->Pos, n1->Pos, n2->Pos ) )
			type = ImTriangulatorNodeType_Ear;
		else
			type = ImTriangulatorNodeType_Convex;

		// Update lists when a type changes
		if ( type == n1->Type )
			return;
		if ( n1->Type == ImTriangulatorNodeType_Reflex )
			_Reflexes.find_erase_unsorted( n1->Index );
		else if ( n1->Type == ImTriangulatorNodeType_Ear )
			_Ears.find_erase_unsorted( n1->Index );
		if ( type == ImTriangulatorNodeType_Reflex )
			_Reflexes.push_back( n1 );
		else if ( type == ImTriangulatorNodeType_Ear )
			_Ears.push_back( n1 );
		n1->Type = type;
	}

	//////////////////////////////////////////////////////////////////////////
	// Style
	//////////////////////////////////////////////////////////////////////////
	static Style s_Style;

	Style& GetStyle()
	{
		return s_Style;
	}

	void ImVectorUniqueEdge( int& size, ImVector<ImEdgeIdx>& edges )
	{
		size = edges.size();
		for ( int p = 0; p < size; ++p )
		{
			for ( int q = p + 1; q < size; ++q )
			{
				if ( edges[ p ].a == edges[ q ].a &&
					 edges[ p ].b == edges[ q ].b )
				{
					while ( edges[ p ].a == edges[ q ].a &&
							edges[ p ].b == edges[ q ].b )
					{
						// Flag non-unique edges with -index of the duplicate edge
						edges[ q ].a = -p;
						//edges[ q ].b = -p;
						//ImEdgeIdx last = vector[ size - 1 ];
						//vector[ size - 1 ] = vector[ q ];
						//vector[ q ] = last;
						--size;
					}
				}
			}
		}
		//vector.resize( size );
	}

	int GetEdgeIndex( ImVector<ImEdgeIdx> const& edges, ImEdgeIdx e )
	{
		int edge_count = edges.size();
		for ( int k = 0; k < edge_count; ++k )
		{
			ImEdgeIdx const& cur = edges[ k ];
			if ( cur.a == e.a && cur.b == e.b )
				return k;
		}

		return -1;
	}

	ImDrawIdx GetOtherIdx( ImDrawIdx a, ImDrawIdx b, ImTriIdx& tri )
	{
		if ( a == tri.a )
		{
			if ( b == tri.b )
			{
				return tri.c;
			}
			else if ( b == tri.c )
			{
				return tri.b;
			}
		}
		else if ( a == tri.b )
		{
			if ( b == tri.a )
			{
				return tri.c;
			}
			else if ( b == tri.c )
			{
				return tri.a;
			}
		}
		else if ( a == tri.c )
		{
			if ( b == tri.a )
			{
				return tri.b;
			}
			else if ( b == tri.b )
			{
				return tri.a;
			}
		}

		return -1;
	}

	void GetOtherIdxOrdered( ImDrawIdx& a, ImDrawIdx& b, ImTriIdx& tri, ImDrawIdx p )
	{
		if ( p == tri.a )
		{
			a = tri.b;
			b = tri.c;
			return;
		}
		else if ( p == tri.b )
		{
			a = tri.c;
			b = tri.a;
			return;
		}
		else if ( p == tri.c )
		{
			a = tri.a;
			b = tri.b;
			return;
		}

		a = (ImDrawIdx)(-1);
		b = (ImDrawIdx)(-1);
	}

	float ImCross( ImVec2 v1, ImVec2 v2 )
	{
		return v1.x * v2.y - v1.y * v2.x;
	}

	float ImTriangleSignedArea( ImVec2 va, ImVec2 vb, ImVec2 vc )
	{
		return 0.5f * ( va.x * ( vb.y - vc.y ) + vb.x * ( vc.y - va.y ) + vc.x * ( va.y - vb.y ) );
	}

	int CheckWinding( ImVec2 va, ImVec2 vb, ImVec2 vc )
	{
		ImVec2 v1 = { vb.x - va.x, vb.y - va.y };
		ImVec2 v2 = { vc.x - va.x, vc.y - va.y };

		//float cross = ImCross( v1, v2 );
		float signed_area = ImTriangleSignedArea( va, vb, vc );

		if ( signed_area > 0.0f )
		{
			// Counterclockwise (CCW)
			return 1;
		}
		else if ( signed_area < 0.0f )
		{
			// Clockwise (CW)
			return -1;
		}
		else
		{
			// Collinear
			return 0;
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// Geometry Generation
	//////////////////////////////////////////////////////////////////////////
#ifdef DEAR_WIDGETS_TESSELATION
	#pragma optimize( "", off )
	void	ShapeTesselationUniform( ImShape& shape )
	{
		int vtx_count = shape.vertices.size();
		int tri_count = shape.triangles.size();

		typedef std::pair<ImDrawIdx, ImDrawIdx> Edge;
		std::map<Edge, ImVertex> edge_to_vrtx;
		for ( int k = 0; k < tri_count; ++k )
		{
			ImTriIdx const& tri = shape.triangles[ k ];

			ImDrawIdx a = tri.a;
			ImDrawIdx b = tri.b;
			ImDrawIdx c = tri.c;

			ImVec2 va = shape.vertices[ a ].pos;
			ImVec2 vb = shape.vertices[ b ].pos;
			ImVec2 vc = shape.vertices[ c ].pos;

			ImVec2 uva = shape.vertices[ a ].uv;
			ImVec2 uvb = shape.vertices[ b ].uv;
			ImVec2 uvc = shape.vertices[ c ].uv;

			ImVec4 cola = ImGui::ColorConvertU32ToFloat4( shape.vertices[ a ].col );
			ImVec4 colb = ImGui::ColorConvertU32ToFloat4( shape.vertices[ b ].col );
			ImVec4 colc = ImGui::ColorConvertU32ToFloat4( shape.vertices[ c ].col );
 
			Edge ab = { ImMin( a, b ), ImMax( a, b ) };
			Edge bc = { ImMin( b, c ), ImMax( b, c ) };
			Edge ca = { ImMin( c, a ), ImMax( c, a ) };

			float ab_sqr = ImLengthSqr( va - vb );
			float bc_sqr = ImLengthSqr( vb - vc );
			float ca_sqr = ImLengthSqr( vc - va );

			if ( ab_sqr >= bc_sqr && ab_sqr >= ca_sqr )
			{
				ImVec2 v = va * 0.5f + vb * 0.5f;
				ImVec2 uv = uva * 0.5f + uvb * 0.5f;
				ImVec4 col = ImLerp( cola, colb, 0.5f );
				edge_to_vrtx[ ab ] = { v, uv, ImGui::GetColorU32( col ) };
			}
			else if ( bc_sqr >= ab_sqr && bc_sqr >= ca_sqr )
			{
				ImVec2 v = vb * 0.5f + vc * 0.5f;
				ImVec2 uv = uvb * 0.5f + uvc * 0.5f;
				ImVec4 col = ImLerp( colb, colc, 0.5f );
				edge_to_vrtx[ bc ] = { v, uv, ImGui::GetColorU32( col ) };
			}
			else if ( ca_sqr >= ab_sqr && ca_sqr >= bc_sqr )
			{
				ImVec2 v = vc * 0.5f + va * 0.5f;
				ImVec2 uv = uvc * 0.5f + uva * 0.5f;
				ImVec4 col = ImLerp( colc, cola, 0.5f );
				edge_to_vrtx[ ca ] = { v, uv, ImGui::GetColorU32( col ) };
			}
			else
			{
				__debugbreak();
			}
		}
		int new_vrtx_count = 0;
		std::map<Edge, int> edge_to_idx;
		for ( auto const& x : edge_to_vrtx )
		{
			edge_to_idx[ x.first ] = vtx_count + new_vrtx_count;
			++new_vrtx_count;
		}
		shape.vertices.resize( vtx_count + new_vrtx_count );
		int vidx = 0;
		for ( auto const& x : edge_to_vrtx )
		{
			shape.vertices[ vtx_count + vidx ] = x.second;
			++vidx;
		}

		ImVector<ImTriIdx> new_indices;
		for ( int k = 0; k < tri_count; ++k )
		{
			ImTriIdx const& tri = shape.triangles[ k ];

			ImDrawIdx a = tri.a;
			ImDrawIdx b = tri.b;
			ImDrawIdx c = tri.c;

			Edge ab = { ImMin( a, b ), ImMax( a, b ) };
			Edge bc = { ImMin( b, c ), ImMax( b, c ) };
			Edge ca = { ImMin( c, a ), ImMax( c, a ) };

			bool is_ab = false;
			bool is_bc = false;
			bool is_ca = false;
			int new_vrtx_count = 0;
			if ( edge_to_vrtx.find( ab ) != edge_to_vrtx.end() )
			{
				++new_vrtx_count;
				is_ab = true;
			}
			if ( edge_to_vrtx.find( bc ) != edge_to_vrtx.end() )
			{
				++new_vrtx_count;
				is_bc = true;
			}
			if ( edge_to_vrtx.find( ca ) != edge_to_vrtx.end() )
			{
				++new_vrtx_count;
				is_ca = true;
			}
			if ( new_vrtx_count == 0 )
			{
				new_indices.push_back( { a, b, c } );
				__debugbreak();
			}
			else if ( new_vrtx_count == 1 )
			{
				if ( is_ab )
				{
					ImDrawIdx new_ab = edge_to_idx[ ab ];
					IM_ASSERT( new_ab > vtx_count );
					new_indices.push_back( { a, new_ab, c } );
					new_indices.push_back( { c, new_ab, b } );
				}
				else if ( is_bc )
				{
					ImDrawIdx new_bc = edge_to_idx[ bc ];
					IM_ASSERT( new_bc > vtx_count );
					new_indices.push_back( { b, new_bc, a } );
					new_indices.push_back( { a, new_bc, c } );
				}
				else if ( is_ca )
				{
					ImDrawIdx new_ca = edge_to_idx[ ca ];
					IM_ASSERT( new_ca > vtx_count );
					new_indices.push_back( { c, new_ca, b } );
					new_indices.push_back( { b, new_ca, a } );
				}
				else
				{
					__debugbreak();
				}
			}
			else if ( new_vrtx_count == 2 )
			{
				if ( is_ab && is_bc )
				{
					ImDrawIdx new_ab = edge_to_idx[ ab ];
					ImDrawIdx new_bc = edge_to_idx[ bc ];
					IM_ASSERT( new_ab > vtx_count );
					IM_ASSERT( new_bc > vtx_count );
					new_indices.push_back( { a, new_ab, new_bc } );
					new_indices.push_back( { b, new_bc, new_ab } );
					new_indices.push_back( { c, a, new_bc } );
				}
				else if ( is_bc && is_ca )
				{
					ImDrawIdx new_bc = edge_to_idx[ bc ];
					ImDrawIdx new_ca = edge_to_idx[ ca ];
					IM_ASSERT( new_bc > vtx_count );
					IM_ASSERT( new_ca > vtx_count );
					new_indices.push_back( { b, new_bc, new_ca } );
					new_indices.push_back( { a, b, new_ca } );
					new_indices.push_back( { c, new_ca, new_bc } );
				}
				else if ( is_ca && is_ab )
				{
					ImDrawIdx new_ab = edge_to_idx[ ab ];
					ImDrawIdx new_ca = edge_to_idx[ ca ];
					IM_ASSERT( new_ab > vtx_count );
					IM_ASSERT( new_ca > vtx_count );
					new_indices.push_back( { a, new_ab, new_ca } );
					new_indices.push_back( { c, new_ca, new_ab } );
					new_indices.push_back( { b, c, new_ab } );
				}
				else
				{
					__debugbreak();
				}
			}
			else if ( new_vrtx_count == 3 )
			{
				ImDrawIdx new_ab = edge_to_idx[ ab ];
				ImDrawIdx new_bc = edge_to_idx[ bc ];
				ImDrawIdx new_ca = edge_to_idx[ ca ];
				IM_ASSERT( new_ab > vtx_count );
				IM_ASSERT( new_bc > vtx_count );
				IM_ASSERT( new_ca > vtx_count );

				new_indices.push_back( { a, new_ab, new_ca } );
				new_indices.push_back( { b, new_bc, new_ab } );
				new_indices.push_back( { c, new_ca, new_bc } );
				new_indices.push_back( { new_ab, new_bc, new_ca } );
			}
			else
			{
				__debugbreak();
			}
		}
		int new_tri_count = new_indices.size();
		for ( int k = 0; k < new_tri_count; ++k )
		{
			ImTriIdx& tri = new_indices[ k ];

			ImDrawIdx a = tri.a;
			ImDrawIdx b = tri.b;
			ImDrawIdx c = tri.c;

			ImVec2 va = shape.vertices[ a ].pos;
			ImVec2 vb = shape.vertices[ b ].pos;
			ImVec2 vc = shape.vertices[ c ].pos;

			if ( CheckWinding( va, vb, vc ) == -1 )
			{
				//tri.a = a;
				tri.b = c;
				tri.c = b;
			}
		}
		shape.triangles = new_indices;
	}
#endif

	void	ShapeTranslate( ImShape& shape, ImVec2 t )
	{
		int vtx_count = shape.vertices.size();
		for ( int k = 0; k < vtx_count; ++k )
		{
			shape.vertices[ k ].pos += t;
		}
		shape.bb.Min += t;
		shape.bb.Max += t;
	}

	void	ShapeSetDefaultUV( ImShape& shape )
	{
		int vtx_count = shape.vertices.size();
		for ( int k = 0; k < vtx_count; ++k )
		{
			shape.vertices[ k ].uv = ImGui::GetFontTexUvWhitePixel();
		}
	}

	void	ShapeSetDefaultUVCol( ImShape& shape )
	{
		int vtx_count = shape.vertices.size();
		for ( int k = 0; k < vtx_count; ++k )
		{
			shape.vertices[ k ].uv = ImGui::GetFontTexUvWhitePixel();
			shape.vertices[ k ].col = IM_COL32( 255, 255, 255, 255 );
		}
	}

	void	ShapeSetDefaultBoundUV( ImShape& shape )
	{
		int vtx_count = shape.vertices.size();
		for ( int k = 0; k < vtx_count; ++k )
		{
			ImVec2 v = shape.vertices[ k ].pos;
			ImVec2 uv;
			uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
			uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
			shape.vertices[ k ].uv = uv;
		}
	}

	void	ShapeSetDefaultBoundUVWhiteCol( ImShape& shape )
	{
		int vtx_count = shape.vertices.size();
		for ( int k = 0; k < vtx_count; ++k )
		{
			ImVec2 v = shape.vertices[ k ].pos;
			ImVec2 uv;
			uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
			uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
			shape.vertices[ k ].uv = uv;
			shape.vertices[ k ].col = IM_COL32( 255, 255, 255, 255 );
		}
	}

	void	ShapeSetDefaultWhiteCol( ImShape& shape )
	{
		int vtx_count = shape.vertices.size();
		for ( int k = 0; k < vtx_count; ++k )
		{
			shape.vertices[ k ].col = IM_COL32( 255, 255, 255, 255 );
		}
	}

	void	GenShapeRect( ImShape& shape, ImRect const& r )
	{
		shape.vertices.clear();
		shape.triangles.clear();
		shape.vertices.resize( 4 );
		shape.triangles.resize( 2 );
		shape.vertices[ 0 ].pos = r.Min;
		shape.vertices[ 1 ].pos = ImVec2( r.Min.x, r.Max.y );
		shape.vertices[ 2 ].pos = r.Max;
		shape.vertices[ 3 ].pos = ImVec2( r.Max.x, r.Min.y );
		shape.bb = r;

		shape.triangles[ 0 ].a = 0;
		shape.triangles[ 0 ].b = 1;
		shape.triangles[ 0 ].c = 3;
		shape.triangles[ 1 ].a = 3;
		shape.triangles[ 1 ].b = 1;
		shape.triangles[ 1 ].c = 2;
	}

	void	GenShapeCircle( ImShape& shape, ImVec2 center, float radius, int side_count )
	{
		shape.vertices.clear();
		shape.triangles.clear();
		float d0 = 2.0f * IM_PI / ( ( float )( side_count ) );
		shape.vertices.resize( side_count + 1 );
		shape.triangles.resize( side_count );
		shape.vertices[ 0 ].pos = center;
		for ( int k = 0; k < side_count; ++k )
		{
			float _0 = ( ( float )k ) * d0;
			shape.vertices[ k + 1 ].pos.x = center.x + radius * ImCos( _0 );
			shape.vertices[ k + 1 ].pos.y = center.y + radius * ImSin( _0 );
		}
		for ( int k = 0; k < side_count; ++k )
		{
			shape.triangles[ k ].a = 0;
			shape.triangles[ k ].b = ( k + 1 ) % side_count + 1;
			shape.triangles[ k ].c = ( k + 2 ) % side_count + 1;
		}
		shape.bb.Min = center - ImVec2( radius, radius );
		shape.bb.Max = center + ImVec2( radius, radius );
	}
	void	GenShapeCircleArc( ImShape& shape, ImVec2 center, float radius, float angle_min, float angle_max, int side_count )
	{
		shape.vertices.clear();
		shape.triangles.clear();
		float angle_range = angle_max - angle_min;
		float d0 = angle_range / ( ( float )( side_count ) );
		shape.vertices.resize( side_count + 2 );
		shape.triangles.resize( side_count );
		shape.vertices[ 0 ].pos = center;
		shape.bb.Min.x =  FLT_MAX;
		shape.bb.Min.y =  FLT_MAX;
		shape.bb.Max.x = -FLT_MAX;
		shape.bb.Max.y = -FLT_MAX;
		for ( int k = 0; k < side_count + 2; ++k )
		{
			float _0 = angle_min + ( ( float )k ) * d0;
			ImVec2 v;
			v.x = center.x + radius * ImCos( - _0 );
			v.y = center.y + radius * ImSin( - _0 );
			shape.vertices[ k + 1 ].pos.x = v.x;
			shape.vertices[ k + 1 ].pos.y = v.y;
			shape.bb.Min.x = ImMin( shape.bb.Min.x, v.x );
			shape.bb.Min.y = ImMin( shape.bb.Min.y, v.y );
			shape.bb.Max.x = ImMax( shape.bb.Max.x, v.x );
			shape.bb.Max.y = ImMax( shape.bb.Max.y, v.y );
		}
		for ( int k = 0; k < side_count; ++k )
		{
			shape.triangles[ k ].a = 0;
			shape.triangles[ k ].b = k + 1;
			shape.triangles[ k ].c = k + 2;
		}
	}
	void	GenShapeRegularNGon( ImShape& shape, ImVec2 center, float radius, int side_count )
	{
		GenShapeCircle( shape, center, radius, side_count );
	}

	// TODO
	//void	GenShapeFromBezierCubicCurve( ImShape& sshape, ImVector<ImVec2>& path, float thickness, int num_segments )
	//{
	//}
	//void	GenShapeFromBezierQuadraticCurve( ImShape& sshape, ImVector<ImVec2>& path, float thickness, int num_segments )
	//{
	//}

	void	ShapeLinearGradientGeneric( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1, pfSpace2sRGB space2sRGB, pfsRGB2Space sRGB2Space )
	{
		ImVec2 delta = uv_end - uv_start;
		ImVec2 d = ImNormalized( delta );
		float l = 1.0f / ImLength( delta );
		int vtx_count = shape.vertices.size();
		ImVec4 col0v = ImGui::ColorConvertU32ToFloat4( col0 );
		ImVec4 col1v = ImGui::ColorConvertU32ToFloat4( col1 );
		ImVec4 col0k;
		ImVec4 col1k;
		col0k.w = col0v.w;
		col1k.w = col1v.w;
		sRGB2Space( col0v.x, col0v.y, col0v.z, col0k.x, col0k.y, col0k.z );
		sRGB2Space( col1v.x, col1v.y, col1v.z, col1k.x, col1k.y, col1k.z );
		ImVec4 vtxCol;
		for ( int k = 0; k < vtx_count; ++k )
		{
			ImVec2 v = shape.vertices[ k ].pos;
			ImVec2 uv;
			uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
			uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
			ImVec2 c = uv - uv_start;
			float t = ImSaturate( ImDot( d, c ) * l );
			ImVec4 curCol = ImLerp( col0k, col1k, t );
			vtxCol.w = curCol.w;
			space2sRGB( curCol.x, curCol.y, curCol.z, vtxCol.x, vtxCol.y, vtxCol.z );
			shape.vertices[ k ].col = ImGui::GetColorU32( vtxCol );
		}
	}
	void	ShapeRadialGradientGeneric( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1, pfSpace2sRGB space2sRGB, pfsRGB2Space sRGB2Space )
	{
		ImVec2 delta = uv_end - uv_start;
		float l = 1.0f / ImLength( delta );
		int vtx_count = shape.vertices.size();
		ImVec4 col0v = ImGui::ColorConvertU32ToFloat4( col0 );
		ImVec4 col1v = ImGui::ColorConvertU32ToFloat4( col1 );
		ImVec4 col0k;
		ImVec4 col1k;
		col0k.w = col0v.w;
		col1k.w = col1v.w;
		sRGB2Space( col0v.x, col0v.y, col0v.z, col0k.x, col0k.y, col0k.z );
		sRGB2Space( col1v.x, col1v.y, col1v.z, col1k.x, col1k.y, col1k.z );
		ImVec4 vtxCol;
		for ( int k = 0; k < vtx_count; ++k )
		{
			ImVec2 v = shape.vertices[ k ].pos;
			ImVec2 uv;
			uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
			uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
			float t = ImSaturate( ImLength( uv - uv_start ) * l );
			ImVec4 curCol = ImLerp( col0k, col1k, t );
			vtxCol.w = curCol.w;
			space2sRGB( curCol.x, curCol.y, curCol.z, vtxCol.x, vtxCol.y, vtxCol.z );
			shape.vertices[ k ].col = ImGui::GetColorU32( vtxCol );
		}
	}
	// Just L1-Norm
	void	ShapeDiamondGradientGeneric( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1, pfSpace2sRGB space2sRGB, pfsRGB2Space sRGB2Space )
	{
		ImVec2 delta = uv_end - uv_start;
		float l = 1.0f / ImLengthL1( delta );
		int vtx_count = shape.vertices.size();
		ImVec4 col0v = ImGui::ColorConvertU32ToFloat4( col0 );
		ImVec4 col1v = ImGui::ColorConvertU32ToFloat4( col1 );
		ImVec4 col0k;
		ImVec4 col1k;
		col0k.w = col0v.w;
		col1k.w = col1v.w;
		sRGB2Space( col0v.x, col0v.y, col0v.z, col0k.x, col0k.y, col0k.z );
		sRGB2Space( col1v.x, col1v.y, col1v.z, col1k.x, col1k.y, col1k.z );
		ImVec4 vtxCol;
		for ( int k = 0; k < vtx_count; ++k )
		{
			ImVec2 v = shape.vertices[ k ].pos;
			ImVec2 uv;
			uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
			uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
			float t = ImSaturate( ImLengthL1( uv - uv_start ) * l );
			ImVec4 curCol = ImLerp( col0k, col1k, t );
			vtxCol.w = curCol.w;
			space2sRGB( curCol.x, curCol.y, curCol.z, vtxCol.x, vtxCol.y, vtxCol.z );
			shape.vertices[ k ].col = ImGui::GetColorU32( vtxCol );
		}
	}

	void	ShapeSRGBLinearGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		//ImVec2 delta = uv_end - uv_start;
		//ImVec2 d = ImNormalized( delta );
		//float l = 1.0f / ImLength( delta );
		//int vtx_count = shape.vertices.size();
		//for ( int k = 0; k < vtx_count; ++k )
		//{
		//	ImVec2 v = shape.vertices[ k ].pos;
		//	ImVec2 uv;
		//	uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
		//	uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
		//	ImVec2 c = uv - uv_start;
		//	float t = ImSaturate( ImDot( d, c ) * l );
		//	shape.vertices[ k ].col = ImColorBlendsRGB( col0, col1, t );
		//}
		ShapeLinearGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertsRGBtosRGB, &ColorConvertsRGBtosRGB );
	}
	void	ShapeSRGBRadialGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		//ImVec2 delta = uv_end - uv_start;
		//float l = 1.0f / ImLength( delta );
		//int vtx_count = shape.vertices.size();
		//for ( int k = 0; k < vtx_count; ++k )
		//{
		//	ImVec2 v = shape.vertices[ k ].pos;
		//	ImVec2 uv;
		//	uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
		//	uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
		//	float t = ImSaturate( ImLength( uv - uv_start ) * l );
		//	shape.vertices[ k ].col = ImColorBlendsRGB( col0, col1, t );
		//}
		ShapeRadialGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertsRGBtosRGB, &ColorConvertsRGBtosRGB );
	}
	// Just L1-Norm
	void	ShapeSRGBDiamondGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		//ImVec2 delta = uv_end - uv_start;
		//float l = 1.0f / ImLengthL1( delta );
		//int vtx_count = shape.vertices.size();
		//for ( int k = 0; k < vtx_count; ++k )
		//{
		//	ImVec2 v = shape.vertices[ k ].pos;
		//	ImVec2 uv;
		//	uv.x = Normalize01( v.x, shape.bb.Min.x, shape.bb.Max.x );
		//	uv.y = Normalize01( v.y, shape.bb.Min.y, shape.bb.Max.y );
		//	float t = ImSaturate( ImLengthL1( uv - uv_start ) * l );
		//	shape.vertices[ k ].col = ImColorBlendsRGB( col0, col1, t );
		//}
		ShapeDiamondGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertsRGBtosRGB, &ColorConvertsRGBtosRGB );
	}
	void	ShapeOkLabLinearGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeLinearGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertOKLABtoRGB, &ColorConvertRGBtoOKLAB );
	}
	void	ShapeOkLabRadialGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeRadialGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertOKLABtoRGB, &ColorConvertRGBtoOKLAB );
	}
	void	ShapeOkLabDiamondGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeDiamondGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertOKLABtoRGB, &ColorConvertRGBtoOKLAB );
	}

	void	ShapeOkLchLinearGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeLinearGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertOKLCHtosRGB, &ColorConvertsRGBtoOKLCH );
	}
	void	ShapeOkLchRadialGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeRadialGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertOKLCHtosRGB, &ColorConvertsRGBtoOKLCH );
	}
	void	ShapeOkLchDiamondGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeDiamondGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertOKLCHtosRGB, &ColorConvertsRGBtoOKLCH );
	}

	void	ShapeLinearSRGBLinearGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeLinearGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertLineartoRGB, &ColorConvertRGBtoLinear );
	}
	void	ShapeLinearSRGBRadialGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeRadialGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertLineartoRGB, &ColorConvertRGBtoLinear );
	}
	void	ShapeLinearSRGBDiamondGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeDiamondGradientGeneric( shape, uv_start, uv_end, col0, col1, &ColorConvertLineartoRGB, &ColorConvertRGBtoLinear );
	}

	void	ShapeHSVLinearGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeLinearGradientGeneric( shape, uv_start, uv_end, col0, col1, &ImGui::ColorConvertHSVtoRGB, &ImGui::ColorConvertRGBtoHSV );
	}
	void	ShapeHSVRadialGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeRadialGradientGeneric( shape, uv_start, uv_end, col0, col1, &ImGui::ColorConvertHSVtoRGB, &ImGui::ColorConvertRGBtoHSV );
	}
	void	ShapeHSVDiamondGradient( ImShape& shape, ImVec2 uv_start, ImVec2 uv_end, ImU32 col0, ImU32 col1 )
	{
		ShapeDiamondGradientGeneric( shape, uv_start, uv_end, col0, col1, &ImGui::ColorConvertHSVtoRGB, &ImGui::ColorConvertRGBtoHSV );
	}

	//////////////////////////////////////////////////////////////////////////
	// DrawList
	//////////////////////////////////////////////////////////////////////////
	void DrawShapeDebugEx( ImDrawList* pDrawList, ImTextureID tex, ImShape& shape, float edge_thickness, ImU32 edge_col, ImU32 triangle_col, float vrtx_radius, ImU32 vrtx_col, int tri_idx )
	{
		const bool push_texture_id = tex != pDrawList->_CmdHeader.TextureId;
		if ( push_texture_id )
			pDrawList->PushTextureID( tex );

		int vtx_count = shape.vertices.size();
		int tri_count = shape.triangles.size();
		if ( tri_idx >= 0 && tri_idx < tri_count )
		{
			pDrawList->PrimReserve( 3, 3 );
			ImDrawIdx a = shape.triangles[ tri_idx ].a;
			ImDrawIdx b = shape.triangles[ tri_idx ].b;
			ImDrawIdx c = shape.triangles[ tri_idx ].c;

			ImVertex const& va = shape.vertices[ a ];
			ImVertex const& vb = shape.vertices[ b ];
			ImVertex const& vc = shape.vertices[ c ];

			pDrawList->_VtxWritePtr[ 0 ].pos = va.pos;
			pDrawList->_VtxWritePtr[ 0 ].uv = va.uv;
			pDrawList->_VtxWritePtr[ 0 ].col = va.col;
			pDrawList->_VtxWritePtr[ 1 ].pos = vb.pos;
			pDrawList->_VtxWritePtr[ 1 ].uv = vb.uv;
			pDrawList->_VtxWritePtr[ 1 ].col = vb.col;
			pDrawList->_VtxWritePtr[ 2 ].pos = vc.pos;
			pDrawList->_VtxWritePtr[ 2 ].uv = vc.uv;
			pDrawList->_VtxWritePtr[ 2 ].col = vc.col;
			pDrawList->_VtxWritePtr += 3;
			pDrawList->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 0 );
			pDrawList->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 1 );
			pDrawList->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 2 );
			pDrawList->_IdxWritePtr += 3;
			pDrawList->_VtxCurrentIdx += ( ImDrawIdx )3;
		}
		else
		{
			pDrawList->PrimReserve( 3 * tri_count, vtx_count );
			for ( int k = 0; k < vtx_count; k++ )
			{
				ImVertex const& v = shape.vertices[ k ];;
				pDrawList->_VtxWritePtr[ 0 ].pos = v.pos;
				pDrawList->_VtxWritePtr[ 0 ].uv = v.uv;
				pDrawList->_VtxWritePtr[ 0 ].col = v.col;
				pDrawList->_VtxWritePtr++;
			}
			for ( int k = 0; k < tri_count; k++ )
			{
				pDrawList->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + shape.triangles[ k ].a );
				pDrawList->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + shape.triangles[ k ].b );
				pDrawList->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + shape.triangles[ k ].c );
				pDrawList->_IdxWritePtr += 3;
			}
			pDrawList->_VtxCurrentIdx += ( ImDrawIdx )vtx_count;
		}
		if ( tri_idx >= 0 && tri_idx < tri_count )
		{
			if ( edge_thickness > 0.5f && ( edge_col & IM_COL32_A_MASK ) > 0 )
			{
				pDrawList->AddLine( shape.vertices[ shape.triangles[ tri_idx ].a ].pos, shape.vertices[ shape.triangles[ tri_idx ].b ].pos, edge_col, edge_thickness );
				pDrawList->AddLine( shape.vertices[ shape.triangles[ tri_idx ].b ].pos, shape.vertices[ shape.triangles[ tri_idx ].c ].pos, edge_col, edge_thickness );
				pDrawList->AddLine( shape.vertices[ shape.triangles[ tri_idx ].c ].pos, shape.vertices[ shape.triangles[ tri_idx ].a ].pos, edge_col, edge_thickness );
			}
			if ( vrtx_radius > 0.0f && ( vrtx_col & IM_COL32_A_MASK ) > 0 )
			{
				pDrawList->AddCircleFilled( shape.vertices[ shape.triangles[ tri_idx ].a ].pos, vrtx_radius, vrtx_col, 0 );
				pDrawList->AddCircleFilled( shape.vertices[ shape.triangles[ tri_idx ].b ].pos, vrtx_radius, vrtx_col, 0 );
				pDrawList->AddCircleFilled( shape.vertices[ shape.triangles[ tri_idx ].c ].pos, vrtx_radius, vrtx_col, 0 );
				pDrawList->AddText( shape.vertices[ shape.triangles[ tri_idx ].a ].pos, IM_COL32_WHITE, "A" );
				pDrawList->AddText( shape.vertices[ shape.triangles[ tri_idx ].b ].pos, IM_COL32_WHITE, "B" );
				pDrawList->AddText( shape.vertices[ shape.triangles[ tri_idx ].c ].pos, IM_COL32_WHITE, "C" );
			}
		}
		else
		{
			if ( edge_thickness > 0.5f && ( edge_col & IM_COL32_A_MASK ) > 0 )
			{
				for ( int k = 0; k < tri_count; ++k )
				{
					pDrawList->AddLine( shape.vertices[ shape.triangles[ k ].a ].pos, shape.vertices[ shape.triangles[ k ].b ].pos, edge_col, edge_thickness );
					pDrawList->AddLine( shape.vertices[ shape.triangles[ k ].b ].pos, shape.vertices[ shape.triangles[ k ].c ].pos, edge_col, edge_thickness );
					pDrawList->AddLine( shape.vertices[ shape.triangles[ k ].c ].pos, shape.vertices[ shape.triangles[ k ].a ].pos, edge_col, edge_thickness );
				}
			}
			if ( vrtx_radius > 0.0f && (vrtx_col & IM_COL32_A_MASK) > 0 )
			{
				for ( int k = 0; k < vtx_count; ++k )
					pDrawList->AddCircleFilled( shape.vertices[ k ].pos, vrtx_radius, vrtx_col, 0 );
			}
		}

		if ( push_texture_id )
			pDrawList->PopTextureID();
	}
	void DrawShapeEx( ImDrawList* pDrawList, ImTextureID tex, ImShape& shape )
	{
		const bool push_texture_id = tex != pDrawList->_CmdHeader.TextureId;
		if ( push_texture_id )
			pDrawList->PushTextureID( tex );

		int vtx_count = shape.vertices.size();
		int tri_count = shape.triangles.size();
		pDrawList->PrimReserve( 3 * tri_count, vtx_count );
		for ( int k = 0; k < vtx_count; k++ )
		{
			ImVertex const& v = shape.vertices[ k ];
			pDrawList->_VtxWritePtr[ 0 ].pos = v.pos;
			pDrawList->_VtxWritePtr[ 0 ].uv = v.uv;
			pDrawList->_VtxWritePtr[ 0 ].col = v.col;
			pDrawList->_VtxWritePtr++;
		}
		for ( int k = 0; k < tri_count; k++ )
		{
			pDrawList->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + shape.triangles[ k ].a );
			pDrawList->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + shape.triangles[ k ].b );
			pDrawList->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + shape.triangles[ k ].c );
			pDrawList->_IdxWritePtr += 3;
		}
		pDrawList->_VtxCurrentIdx += ( ImDrawIdx )vtx_count;

		if ( push_texture_id )
			pDrawList->PopTextureID();
	}
	void DrawShapeDebug( ImDrawList* pDrawList, ImShape& shape, float edge_thickness, ImU32 edge_col, ImU32 triangle_col, float vrtx_radius, ImU32 vrtx_col, int tri_idx )
	{
		// If we don't have a texture_id send the one on the header, it will discard the set of texture on DrawShapeEx
		DrawShapeDebugEx( pDrawList, pDrawList->_CmdHeader.TextureId, shape, edge_thickness, edge_col, triangle_col, vrtx_radius, vrtx_col, tri_idx );
	}
	void DrawShape( ImDrawList* pDrawList, ImShape& shape )
	{
		// If we don't have a texture_id send the one on the header, it will discard the set of texture on DrawShapeEx
		DrawShapeEx( pDrawList, pDrawList->_CmdHeader.TextureId, shape );
	}
	void DrawImageShapeDebug( ImDrawList* pDrawList, ImTextureID tex, ImShape& shape, float edge_thickness, ImU32 edge_col, ImU32 triangle_col, float vrtx_radius, ImU32 vrtx_col, int tri_idx )
	{
		DrawShapeDebugEx( pDrawList, tex, shape, edge_thickness, edge_col, triangle_col, vrtx_radius, vrtx_col, tri_idx );
	}
	void DrawImageShape( ImDrawList* pDrawList, ImTextureID tex, ImShape& shape )
	{
		DrawShapeEx( pDrawList, tex, shape );
	}

	void GetTrianglePointer( ImVec2& a, ImVec2& b, ImVec2& c, ImVec2 targetPoint, float angle, float height )
	{
		//// Simple Work around to have approximatively the tip on the target point
		//// TODO: Find better solution
		//if ( thickness > 0.0f )
		//	targetPoint += ImVec2( 0.0f, thickness * 0.5f );

		float cos2pi_3 = ImCos( ( 2.0f / 3.0f ) * IM_PI );
		float sin2pi_3 = ImSin( ( 2.0f / 3.0f ) * IM_PI );

		// minus to have the pointer turning in positive
		// PI/2 to have the triangle pointing up when angle == 0.0f
		float cos0 = ImCos( -angle - IM_PI * 0.5f );
		float sin0 = ImSin( -angle - IM_PI * 0.5f );

		ImVec2 center = targetPoint + ImVec2( -1.0f, 0.0f );
		b = ImVec2( cos2pi_3 - 1.0f, sin2pi_3 );
		c = ImVec2( cos2pi_3 - 1.0f, -sin2pi_3 );

		a = targetPoint;
		b = ImRotate( b, cos0, sin0 ) * 2.0f * height / 3.0f + targetPoint;
		c = ImRotate( c, cos0, sin0 ) * 2.0f * height / 3.0f + targetPoint;
	}

	void DrawTriangleCursor( ImDrawList* pDrawList, ImVec2 targetPoint, float angle, float size, float thickness, ImU32 col )
	{
		ImVec2 a, b, c;
		GetTrianglePointer( a, b, c, targetPoint, angle, size );

		pDrawList->AddTriangle( a, b, c, col, thickness );
	}

	void DrawTriangleCursorFilled( ImDrawList* pDrawList, ImVec2 targetPoint, float angle, float size, ImU32 col )
	{
		ImVec2 a, b, c;
		GetTrianglePointer( a, b, c, targetPoint, angle, size );

		pDrawList->AddTriangleFilled( a, b, c, col );
	}

	void GetRotatePoints( ImVec2* pts, int pts_count, ImVec2 pivot, float angle )
	{
		float cos0 = ImCos( angle );
		float sin0 = ImSin( angle );
		ImVec2 t;
		for ( int k = 0; k < pts_count; ++k )
		{
			t = pts[ k ] - pivot;
			ImVec2 r;
			r.x = t.x * cos0 - t.y * sin0;
			r.y = t.x * sin0 + t.y * cos0;
			pts[ k ] = r + pivot;
		}
	}

	void ImInternalGetSignetVertices( ImVec2* pts, int pts_count, ImVec2 targetPoint, float width, float height, float height_ratio, float align01, float angle, float thickness )
	{
		//// Simple Work around to have approximatively the tip on the target point
		//// TODO: Find better solution
		//if ( thickness > 0.0f )
		//	targetPoint += ImVec2( 0.0f, thickness * 0.5f );

		float left = ImLerp( targetPoint.x - width, targetPoint.x, align01 );
		float right = left + width;
		float top = ImLerp( targetPoint.y, targetPoint.y + height, height_ratio );
		float bottom = targetPoint.y + height;

		pts[ 0 ] = targetPoint;
		pts[ 1 ] = ImVec2( left, top );
		pts[ 2 ] = ImVec2( left, bottom );
		pts[ 3 ] = ImVec2( right, bottom );
		pts[ 4 ] = ImVec2( right, top );

		GetRotatePoints( &pts[ 0 ], pts_count, targetPoint, angle );
	}

	void DrawSignetCursor( ImDrawList* pDrawList, ImVec2 targetPoint, float width, float height, float height_ratio, float align01, float angle, float thickness, ImU32 col )
	{
		ImVec2 pts[ 5 ];
		ImInternalGetSignetVertices( &pts[ 0 ], 5, targetPoint, width, height, height_ratio, align01, angle, thickness );

		pDrawList->AddPolyline( &pts[ 0 ], 5, col, ImDrawFlags_Closed, thickness );
	}

	void DrawSignetFilledCursor( ImDrawList* pDrawList, ImVec2 targetPoint, float width, float height, float height_ratio, float align01, float angle, ImU32 col )
	{
		ImVec2 pts[ 5 ];
		ImInternalGetSignetVertices( &pts[ 0 ], 5, targetPoint, width, height, height_ratio, align01, angle, 0.0f );

		pDrawList->AddConvexPolyFilled( &pts[ 0 ], 5, col );
	}

	void DrawProceduralColor1DNearest( ImDrawList* pDrawList, ImColor1DCallback func, void* pUserData, float minX, float maxX, ImVec2 position, ImVec2 size, int resolutionX )
	{
		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

		float const sx = size.x / ( ( float )resolutionX );

		float const dx = 1.0f / ( ( float )resolutionX );
		float const hdx = 0.5f / ( ( float )resolutionX );

		for ( int i = 0; i < resolutionX; ++i )
		{
			float x0;
			float x1; ( void )x1;
			x0 = ScaleFromNormalized( ( ( float )i + 0 ) * dx + hdx, minX, maxX );

			ImU32 const col00 = func( x0 , pUserData );
			pDrawList->AddRectFilledMultiColor( position + ImVec2( sx * ( i + 0 ), 0.0f ),
												position + ImVec2( sx * ( i + 1 ), size.y ),
												col00, col00, col00, col00 );
		}
	}

	void DrawProceduralColor1DBilinear( ImDrawList* pDrawList, ImColor1DCallback func, void* pUserData, float minX, float maxX, ImVec2 position, ImVec2 size, int resolutionX )
	{
		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

		float const sx = size.x / ( ( float )resolutionX );

		float const dx = 1.0f / ( ( float )resolutionX );
		float const hdx = 0.5f / ( ( float )resolutionX );

		for ( int i = 0; i < resolutionX; ++i )
		{
			float x0;
			float x1; ( void )x1;
			x0 = ScaleFromNormalized( ( ( float )i + 0 ) * dx, minX, maxX );
			x1 = ScaleFromNormalized( ( ( float )i + 1 ) * dx, minX, maxX );

			ImU32 const col00 = func( x0, pUserData );
			ImU32 const col01 = func( x0, pUserData );
			ImU32 const col10 = func( x1, pUserData );
			ImU32 const col11 = func( x1, pUserData );
			pDrawList->AddRectFilledMultiColor( position + ImVec2( sx * ( i + 0 ), 0.0f ),
												position + ImVec2( sx * ( i + 1 ), size.y ),
												col00, col10, col11, col01 );
		}
	}

	void DrawProceduralColor2DNearest( ImDrawList* pDrawList, ImColor2DCallback func, void* pUserData, float minX, float maxX, float minY, float maxY, ImVec2 position, ImVec2 size, int resolutionX, int resolutionY )
	{
		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

		float const sx = size.x / ( ( float )resolutionX );
		float const sy = size.y / ( ( float )resolutionY );

		float const dy = 1.0f / ( ( float )resolutionY );
		float const dx = 1.0f / ( ( float )resolutionX );
		float const hdx = 0.5f / ( ( float )resolutionX );
		float const hdy = 0.5f / ( ( float )resolutionY );

		for ( int i = 0; i < resolutionX; ++i )
		{
			float x0;
			float x1; ( void )x1;
			x0 = ScaleFromNormalized( ( ( float )i + 0 ) * dx + hdx, minX, maxX );

			for ( int j = 0; j < resolutionY; ++j )
			{
				float y0;
				float y1; ( void )y1;
				y0 = ScaleFromNormalized( ( ( float )( j + 0 ) * dy + hdy ), maxY, minY );

				ImU32 const col00 = func( x0, y0, pUserData );
				pDrawList->AddRectFilledMultiColor( position + ImVec2( sx * ( i + 0 ), sy * ( j + 0 ) ),
													position + ImVec2( sx * ( i + 1 ), sy * ( j + 1 ) ),
													col00, col00, col00, col00 );
			}
		}
	}

	void DrawProceduralColor2DBilinear( ImDrawList* pDrawList, ImColor2DCallback func, void* pUserData, float minX, float maxX, float minY, float maxY, ImVec2 position, ImVec2 size, int resolutionX, int resolutionY )
	{
		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

		float const sx = size.x / ( ( float )resolutionX );
		float const sy = size.y / ( ( float )resolutionY );

		float const dy = 1.0f / ( ( float )resolutionY );
		float const dx = 1.0f / ( ( float )resolutionX );
		float const hdx = 0.5f / ( ( float )resolutionX );
		float const hdy = 0.5f / ( ( float )resolutionY );

		for ( int i = 0; i < resolutionX; ++i )
		{
			float x0;
			float x1; ( void )x1;
			x0 = ScaleFromNormalized( ( ( float )i + 0 ) * dx, minX, maxX );
			x1 = ScaleFromNormalized( ( ( float )i + 1 ) * dx, minX, maxX );

			for ( int j = 0; j < resolutionY; ++j )
			{
				float y0;
				float y1; ( void )y1;
				y0 = ScaleFromNormalized( ( ( float )( j + 0 ) * dy ), maxY, minY );
				y1 = ScaleFromNormalized( ( ( float )( j + 1 ) * dy ), maxY, minY );

				ImU32 const col00 = func( x0, y0, pUserData );
				ImU32 const col01 = func( x0, y1, pUserData );
				ImU32 const col10 = func( x1, y0, pUserData );
				ImU32 const col11 = func( x1, y1, pUserData );
				pDrawList->AddRectFilledMultiColor( position + ImVec2( sx * ( i + 0 ), sy * ( j + 0 ) ),
													position + ImVec2( sx * ( i + 1 ), sy * ( j + 1 ) ),
													col00, col10, col11, col01 );
			}
		}
	}
	
	ImU32 ImInternalHueFunc( float ttt, void* pUserData )
	{
		float alpha = ( ( float* )pUserData )[ 0 ];
		float offset = ( ( float* )pUserData )[ 1 ];
		float gamma = ( ( float* )pUserData )[ 2 ];
		float tt = ImPow( ttt, gamma );
		float t;
		if ( tt - offset < 0.0f )
			t = ImFmod( 1.0f + ( tt - offset ), 1.0f );
		else
			t = ImFmod( tt - offset, 1.0f );

		float r, g, b;
		ImGui::ColorConvertHSVtoRGB( t, 1.0f, 1.0f, r, g, b );
		int const ur = static_cast< int >( 255.0f * r );
		int const ug = static_cast< int >( 255.0f * g );
		int const ub = static_cast< int >( 255.0f * b );
		int const ua = static_cast< int >( 255.0f * alpha );
		return IM_COL32( ur, ug, ub, ua );
	};
	void DrawHueBand( ImDrawList* pDrawList, ImVec2 const vpos, ImVec2 const size, int division, float alpha, float gamma, float offset )
	{
		float data[] = { alpha, offset, gamma };

		DrawProceduralColor1DBilinear( pDrawList, &ImInternalHueFunc, &data[ 0 ], 0.0f, 1.0f, vpos, size, division );
	}

	void DrawHueBand( ImDrawList* pDrawList, ImVec2 const vpos, ImVec2 const size, int division, float colorStartRGB[ 3 ], float alpha, float gamma )
	{
		float h, s, v;
		ImGui::ColorConvertRGBtoHSV( colorStartRGB[ 0 ], colorStartRGB[ 1 ], colorStartRGB[ 2 ], h, s, v );
		DrawHueBand( pDrawList, vpos, size, division, alpha, gamma, h );
	}

	ImU32 ImInternalLumianceFunc( float tt, void* pUserData )
	{
		float h = ( ( float* )pUserData )[ 0 ];
		float s = ( ( float* )pUserData )[ 1 ];
		float v = ( ( float* )pUserData )[ 2 ];
		float gamma = ( ( float* )pUserData )[ 3 ];
		float t = ImPow( tt, gamma );
		float r, g, b;
		ImGui::ColorConvertHSVtoRGB( h, s, ImLerp( 0.0f, v, t ), r, g, b );
		int const ur = static_cast< int >( 255.0f * r );
		int const ug = static_cast< int >( 255.0f * g );
		int const ub = static_cast< int >( 255.0f * b );
		return IM_COL32( ur, ug, ub, 255 );
	}
	void DrawLumianceBand( ImDrawList* pDrawList, ImVec2 const vpos, ImVec2 const size, int division, ImVec4 const& color, float gamma )
	{
		float h, s, v;
		ImGui::ColorConvertRGBtoHSV( color.x, color.y, color.z, h, s, v );
		float data[] = { h, s, v, gamma };
		DrawProceduralColor1DBilinear( pDrawList, &ImInternalLumianceFunc, &data[ 0 ], 0.0f, 1.0f, vpos, size, division );
	}

	ImU32 ImInternalSaturationFunc( float tt, void* pUserData )
	{
		float h = ( ( float* )pUserData )[ 0 ];
		float s = ( ( float* )pUserData )[ 1 ];
		float v = ( ( float* )pUserData )[ 2 ];
		float gamma = ( ( float* )pUserData )[ 3 ];
		float t = ImPow( tt, gamma );
		float r, g, b;
		ImGui::ColorConvertHSVtoRGB( h, ImLerp( 0.0f, 1.0f, t ) * s, ImLerp( 0.5f, 1.0f, t ) * v, r, g, b );
		int const ur = static_cast< int >( 255.0f * r );
		int const ug = static_cast< int >( 255.0f * g );
		int const ub = static_cast< int >( 255.0f * b );
		return IM_COL32( ur, ug, ub, 255 );
	}
	void DrawSaturationBand( ImDrawList* pDrawList, ImVec2 const vpos, ImVec2 const size, int division, ImVec4 const& color, float gamma )
	{
		float h, s, v;
		ImGui::ColorConvertRGBtoHSV( color.x, color.y, color.z, h, s, v );
		float data[] = { h, s, v, gamma };

		DrawProceduralColor1DBilinear( pDrawList, &ImInternalSaturationFunc, &data[ 0 ], 0.0f, 1.0f, vpos, size, division );
	}

	void	DrawColorRing( ImDrawList* pDrawList, ImVec2 const curPos, ImVec2 const size, float thickness_, ImColor1DCallback func, void* pUserData, int division, float colorOffset, bool bIsBilinear )
	{
		float const radius = ImMin( size.x, size.y ) * 0.5f;

		float const dAngle = 2.0f * IM_PI / ( ( float )division );
		float angle = 2.0f * IM_PI / 3.0f;

		ImVec2 offset = curPos + ImVec2( radius, radius );
		if ( size.x < size.y )
		{
			offset.y += 0.5f * ( size.y - size.x );
		}
		else if ( size.x > size.y )
		{
			offset.x += 0.5f * ( size.x - size.y );
		}

		float const thickness = ImSaturate( thickness_ ) * radius;

		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();
		pDrawList->PrimReserve( division * 6, division * 4 );
		for ( int i = 0; i < division; ++i )
		{
			float x0 = radius * ImCos( angle );
			float y0 = radius * ImSin( angle );

			float x1 = radius * ImCos( angle + dAngle );
			float y1 = radius * ImSin( angle + dAngle );

			float x2 = ( radius - thickness ) * ImCos( angle + dAngle );
			float y2 = ( radius - thickness ) * ImSin( angle + dAngle );

			float x3 = ( radius - thickness ) * ImCos( angle );
			float y3 = ( radius - thickness ) * ImSin( angle );

			pDrawList->PrimWriteIdx( ( ImDrawIdx )( pDrawList->_VtxCurrentIdx ) );
			pDrawList->PrimWriteIdx( ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 1 ) );
			pDrawList->PrimWriteIdx( ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 2 ) );

			pDrawList->PrimWriteIdx( ( ImDrawIdx )( pDrawList->_VtxCurrentIdx ) );
			pDrawList->PrimWriteIdx( ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 2 ) );
			pDrawList->PrimWriteIdx( ( ImDrawIdx )( pDrawList->_VtxCurrentIdx + 3 ) );

			float const t0 = fmodf( colorOffset + ( ( float )i ) / ( ( float )division ), 1.0f );
			ImU32 const uCol0 = func( t0, pUserData );

			float const t1 = fmodf( colorOffset + ( ( float )( i + 1 ) ) / ( ( float )division ), 1.0f );
			ImU32 const uCol1 = bIsBilinear ? func( t1, pUserData ) : uCol0;
			pDrawList->PrimWriteVtx( offset + ImVec2( x0, y0 ), uv, uCol0 );
			pDrawList->PrimWriteVtx( offset + ImVec2( x1, y1 ), uv, uCol1 );
			pDrawList->PrimWriteVtx( offset + ImVec2( x2, y2 ), uv, uCol1 );
			pDrawList->PrimWriteVtx( offset + ImVec2( x3, y3 ), uv, uCol0 );
			angle += dAngle;
		}
	}

	ImU32 ImColor2DCallbackOkLab( float a, float b, void* pUserData )
	{
		float* pL = ( float* )pUserData;
		float L = *pL;

		float rr, gg, bb;
		ColorConvertOKLABtoRGB( L, a, b, rr, gg, bb );

		return ImGui::GetColorU32( ImVec4( rr, gg, bb, 1.0f ) );
	}
	ImU32 ImColor2DCallbackOkLch( float x, float y, void* pUserData )
	{
		float* pL = ( float* )pUserData;
		float L = *pL;

		float angle = ImAtan2( y, x );
		float r = ImSqrt( x * x + y * y );

		if ( angle < 0.0f )
			angle += 2.0f * IM_PI;

		float c = r;
		float h = angle / ( 2.0f * IM_PI );

		float rr, gg, bb;
		ColorConvertOKLCHtosRGB( L, c, h, rr, gg, bb );

		return ImGui::GetColorU32( ImVec4( rr, gg, bb, 1.0f ) );
	}

	void DrawOkLabQuad( ImDrawList* pDrawList, ImVec2 start, ImVec2 size, float L, int resX, int resY )
	{
		DrawProceduralColor2DBilinear(
			pDrawList,
			&ImColor2DCallbackOkLab,
			&L,
			0.0f, 1.0f,
			0.0f, 1.0f,
			start, size, resX, resY );
	}
	void DrawOkLchQuad( ImDrawList* pDrawList, ImVec2 start, ImVec2 size, float L, int resX, int resY )
	{
		DrawProceduralColor2DBilinear(
			pDrawList,
			&ImColor2DCallbackOkLch,
			&L,
			-1.0f, 1.0f,
			-1.0f, 1.0f,
			start, size, resX, resY );
	}

	// Adapted version from:
	// cf. https://github.com/ocornut/imgui/issues/760#issuecomment-237195662
	// Remove C++ feature, work with float instead of double, no auto
	// Far from efficient, perf depending no the size, but it work!
	void DrawShapeWithHole( ImDrawList* draw, ImVec2* poly, int points_count, ImU32 color, ImRect* p_bb, int gap, int strokeWidth )
	{
		ImVector<ImVec2> scanHits;
		ImVec2 min, max; // polygon min/max points
		ImGuiIO io = ImGui::GetIO();
		float y;
		bool isMinMaxDone = false;

		// find the orthagonal bounding box
		// probably can put this as a predefined
		if ( !isMinMaxDone )
		{
			min.x = min.y = FLT_MAX;
			max.x = max.y = FLT_MIN;
			//for ( auto p : poly )
			for ( int i = 0; i < points_count; ++i )
			{
				ImVec2 p = poly[ i ];
				if ( p.x < min.x )
					min.x = p.x;
				if ( p.y < min.y )
					min.y = p.y;
				if ( p.x > max.x )
					max.x = p.x;
				if ( p.y > max.y )
					max.y = p.y;
			}
			isMinMaxDone = true;
		}
		ImRect bb;
		if ( p_bb == NULL )
		{
			bb.Min = min;
			bb.Max = max;
		}
		else
		{
			bb = *p_bb;
		}

		// Bounds check
		if ( ( max.x < 0 ) || ( min.x > io.DisplaySize.x ) || ( max.y < 0 ) || ( min.y > io.DisplaySize.y ) )
			return;

		// Vertically clip
		if ( min.y <= 0 )
			min.y = 0;
		if ( max.y > io.DisplaySize.y )
			max.y = io.DisplaySize.y;

		// so we know we start on the outside of the object we step out by 1.
		min.x -= 1;
		max.x += 1;

		// Initialise our starting conditions
		y = min.y;

		struct ImVec2CompX
		{
			static int IMGUI_CDECL Comp( const void* lhs, const void* rhs )
			{
				if ( ( ( const ImVec2* )lhs )->x > ( ( const ImVec2* )rhs )->x )
					return +1;
				if ( ( ( const ImVec2* )lhs )->x < ( ( const ImVec2* )rhs )->x )
					return -1;
				return 0;
			}
		};

		draw->PushClipRect( bb.Min, bb.Max, true );
		// Go through each scan line iteratively, jumping by 'gap' pixels each time
		while ( y < max.y )
		{
			scanHits.clear();
			{
				int jump = 1;
				ImVec2 fp = poly[ 0 ];

				for ( size_t i = 0; i < points_count - 1; i++ )
				{
					ImVec2 pa = poly[ i ];
					ImVec2 pb = poly[ i + 1 ];

					// jump double/dud points
					if ( pa.x == pb.x && pa.y == pb.y ) continue;

					// if we encounter our hull/poly start point, then we've now created the
					// closed
					// hull, jump the next segment and reset the first-point
					if ( ( !jump ) && ( fp.x == pb.x ) && ( fp.y == pb.y ) )
					{
						if ( i < points_count - 2 )
						{
							fp = poly[ i + 2 ];
							jump = 1;
							i++;
						}
					}
					else
					{
						jump = 0;
					}

					// test to see if this segment makes the scan-cut.
					if ( ( pa.y > pb.y && y < pa.y && y > pb.y ) || ( pa.y < pb.y && y > pa.y && y < pb.y ) )
					{
						ImVec2 intersect;

						intersect.y = y;
						if ( pa.x == pb.x )
						{
							intersect.x = pa.x;
						}
						else
						{
							intersect.x = ( pb.x - pa.x ) / ( pb.y - pa.y ) * ( y - pa.y ) + pa.x;
						}
						scanHits.push_back( intersect );
					}
				}

				// Sort the scan hits by X, so we have a proper left->right ordering
				ImQsort( &scanHits[ 0 ], scanHits.size(), sizeof( ImVec2 ), &ImVec2CompX::Comp );

				// generate the line segments.
				{
					int i = 0;
					int l = scanHits.size() - 1; // we need pairs of points, this prevents segfault.
					for ( i = 0; i < l; i += 2 )
					{
						draw->AddLine( scanHits[ i ], scanHits[ i + 1 ], color, ( float )strokeWidth );
					}
				}
			}
			y += gap;
		} // for each scan line
		draw->PopClipRect();

		scanHits.clear();
	}

	void DrawImageConvexShape( ImDrawList* draw, ImTextureID img, ImVec2* poly, int points_count, ImU32 tint,
							   ImVec2 uv_offset, ImVec2 uv_scale )
	{
		if ( points_count < 3 || ( tint & IM_COL32_A_MASK ) == 0 )
			return;

		ImRect bb;
		bb.Min = ImVec2(  FLT_MAX,  FLT_MAX );
		bb.Max = ImVec2( -FLT_MAX, -FLT_MAX );
		for ( ImVec2* v = poly; v < poly + points_count; ++v )
		{
			bb.Min.x = ImMin( bb.Min.x, v->x );
			bb.Min.y = ImMin( bb.Min.y, v->y );
			bb.Max.x = ImMax( bb.Max.x, v->x );
			bb.Max.y = ImMax( bb.Max.y, v->y );
		}

		// TODO add flag to support ImDrawListFlags_AntiAliasedFill
		// cf. AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
		{
			const bool push_texture_id = img != draw->_CmdHeader.TextureId;
			if ( push_texture_id )
				draw->PushTextureID( img );
			const int idx_count = ( points_count - 2 ) * 3;
			const int vtx_count = points_count;
			draw->PrimReserve( idx_count, vtx_count );
			for ( int i = 0; i < vtx_count; i++ )
			{
				draw->_VtxWritePtr[ 0 ].pos = poly[ i ];
				ImVec2 uv;
				uv.x = ImRescale( poly[ i ].x, bb.Min.x, bb.Max.x, 0.0f, 1.0f ) * uv_scale.x + uv_offset.x;
				uv.y = ImRescale( poly[ i ].y, bb.Min.y, bb.Max.y, 0.0f, 1.0f ) * uv_scale.y + uv_offset.y;
				draw->_VtxWritePtr[ 0 ].uv = uv;
				draw->_VtxWritePtr[ 0 ].col = tint;
				draw->_VtxWritePtr++;
			}
			for ( int i = 2; i < points_count; i++ )
			{
				draw->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx );
				draw->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + i - 1 );
				draw->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + i );
				draw->_IdxWritePtr += 3;
			}
			draw->_VtxCurrentIdx += ( ImDrawIdx )vtx_count;
			if ( push_texture_id )
				draw->PopTextureID();
		}
	}

	void DrawImageConcaveShape( ImDrawList* draw, ImTextureID img, ImVec2* poly, int points_count, ImU32 tint,
							   ImVec2 uv_offset, ImVec2 uv_scale )
	{
		if ( points_count < 3 || ( tint & IM_COL32_A_MASK ) == 0 )
			return;

		ImRect bb;
		bb.Min = ImVec2(  FLT_MAX,  FLT_MAX );
		bb.Max = ImVec2( -FLT_MAX, -FLT_MAX );
		for ( ImVec2* v = poly; v < poly + points_count; ++v )
		{
			bb.Min.x = ImMin( bb.Min.x, v->x );
			bb.Min.y = ImMin( bb.Min.y, v->y );
			bb.Max.x = ImMax( bb.Max.x, v->x );
			bb.Max.y = ImMax( bb.Max.y, v->y );
		}

		ImTriangulator0 triangulator;
		unsigned int triangle[ 3 ];
		// TODO add flag to support ImDrawListFlags_AntiAliasedFill
		// cf. AddConcavePolyFilled(const ImVec2* points, const int points_count, ImU32 col)
		{
			const bool push_texture_id = img != draw->_CmdHeader.TextureId;
			if ( push_texture_id )
				draw->PushTextureID( img );
			const int idx_count = ( points_count - 2 ) * 3;
			const int vtx_count = points_count;
			draw->PrimReserve( idx_count, vtx_count );
			for ( int i = 0; i < vtx_count; i++ )
			{
				draw->_VtxWritePtr[ 0 ].pos = poly[ i ];
				ImVec2 uv;
				uv.x = ImRescale( poly[ i ].x, bb.Min.x, bb.Max.x, 0.0f, 1.0f ) * uv_scale.x + uv_offset.x;
				uv.y = ImRescale( poly[ i ].y, bb.Min.y, bb.Max.y, 0.0f, 1.0f ) * uv_scale.y + uv_offset.y;
				draw->_VtxWritePtr[ 0 ].uv = uv;
				draw->_VtxWritePtr[ 0 ].col = tint;
				draw->_VtxWritePtr++;
			}
			draw->_Data->TempBuffer.reserve_discard( ( ImTriangulator0::EstimateScratchBufferSize( points_count ) + sizeof( ImVec2 ) ) / sizeof( ImVec2 ) );
			triangulator.Init( poly, points_count, draw->_Data->TempBuffer.Data );
			while ( triangulator._TrianglesLeft > 0 )
			{
				triangulator.GetNextTriangle( triangle );
				draw->_IdxWritePtr[ 0 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + triangle[ 0 ] );
				draw->_IdxWritePtr[ 1 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + triangle[ 1 ] );
				draw->_IdxWritePtr[ 2 ] = ( ImDrawIdx )( draw->_VtxCurrentIdx + triangle[ 2 ] );
				draw->_IdxWritePtr += 3;
			}
			draw->_VtxCurrentIdx += ( ImDrawIdx )vtx_count;
			if ( push_texture_id )
				draw->PopTextureID();
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// Widgets
	//////////////////////////////////////////////////////////////////////////
	void	DrawChromaticityPlotGeneric( ImDrawList* pDrawList,
										 ImVec2 curPos,
										 ImVec2 size,
										 ImVec2 primR, ImVec2 primG, ImVec2 primB,
										 ImVec2 whitePoint,
										 float* xyzToRGB,
										 int const chromeLineSamplesCount,
										 float* observerX, float* observerY, float* observerZ,
										 int const observerSampleCount,
										 float const observerWavelengthMin, float const observerWavelengthMax,
										 float* standardCIE,
										 int const standardCIESampleCount,
										 float const standardCIEWavelengthMin, float const standardCIEWavelengthMax,
										 float gamma,
										 int resX, int resY,
										 ImU32 maskColor,
										 float wavelengthMin, float wavelengthMax,
										 float minX, float maxX,
										 float minY, float maxY,
										 bool showColorSpaceTriangle,
										 bool showWhitePoint,
										 bool showBorder,
										 ImU32 borderColor,
										 float borderThickness )
	{
		ImVec2 const uv = ImGui::GetFontTexUvWhitePixel();

		float* data[] = { xyzToRGB, &gamma };
		DrawProceduralColor2DBilinear(
				pDrawList,
				[]( float x, float y, void* pUserData ){
					float*	pXYZ2RGB = ( ( float** )pUserData )[ 0 ];
					float	fGamma = *( ( float** )pUserData )[ 1 ];
					return ImColorFrom_xyz( x, y, 1.0f - x - y, pXYZ2RGB, fGamma );
				},
				&data[ 0 ],
				minX, maxX, minY, maxY,
				curPos, size,
				resX, resY );

		//int lineSamples = ImMin( chromeLineSamplesCount, observerSampleCount );

		float illum;
		float x, y, z;
		float sum;
		ImVector<ImVec2> chromLine;
		// +1 to close the line
		// +5 for the enclosure
		//int ptsCount = lineSamples + 1 + 5;
		int ptsCount = chromeLineSamplesCount + 1 + 5;
		chromLine.resize( ptsCount );
		for ( int i = 0; i < chromeLineSamplesCount; ++i )
		{
			float const wavelength = ScaleFromNormalized( ( ( float )i ) / ( ( float )( chromeLineSamplesCount - 1 ) ), wavelengthMin, wavelengthMax );

			illum = ImFunctionFromData( wavelength, standardCIEWavelengthMin, standardCIEWavelengthMax, standardCIE, standardCIESampleCount );
			x = illum * ImFunctionFromData( wavelength, observerWavelengthMin, observerWavelengthMax, observerX, observerSampleCount );
			y = illum * ImFunctionFromData( wavelength, observerWavelengthMin, observerWavelengthMax, observerY, observerSampleCount );
			z = illum * ImFunctionFromData( wavelength, observerWavelengthMin, observerWavelengthMax, observerZ, observerSampleCount );

			sum = x + y + z;
			//sum = x + 15.0f * y + 3.0f * z;

			x /= sum;
			y /= sum;
			//x = 4.0f * x / sum;
			//y = 9.0f * y / sum;

			chromLine[ i ] = ImVec2( x, y );
		}
		chromLine[ chromeLineSamplesCount ] = chromLine[ 0 ];
		//minX, maxX, minY, maxY
		chromLine[ chromeLineSamplesCount + 1 ] = ImVec2( maxX, maxY );
		chromLine[ chromeLineSamplesCount + 2 ] = ImVec2( maxX, minY );
		chromLine[ chromeLineSamplesCount + 3 ] = ImVec2( minX, minY );
		chromLine[ chromeLineSamplesCount + 4 ] = ImVec2( minX, maxY );
		chromLine[ chromeLineSamplesCount + 5 ] = ImVec2( maxX, maxY );
		for ( int i = 0; i < ptsCount; ++i )
		{
			chromLine[ i ].x = Rescale( chromLine[ i ].x, minX, maxX, curPos.x, curPos.x + size.x );
			chromLine[ i ].y = Rescale( chromLine[ i ].y, minY, maxY, curPos.y + size.y, curPos.y - 1.0f );
		}
		// Workaround: Overdraw with strokeWidth of 2. Because we seem to have missing the first and last row of pixel.
		//			The problem is more visible with alpha < 255.
		ImRect clipRect( curPos, curPos + size );
		DrawShapeWithHole( pDrawList, &chromLine[ 0 ], ptsCount, maskColor, &clipRect, 1, 1 );
		if ( borderColor || showColorSpaceTriangle || showWhitePoint )
		{
			pDrawList->PushClipRect( clipRect.Min, clipRect.Max, true );
		}

		if ( showBorder )
		{
			pDrawList->AddPolyline( &chromLine[ 0 ], chromeLineSamplesCount, borderColor, ImDrawFlags_Closed, borderThickness );
		}

		if ( showColorSpaceTriangle )
		{
			ImVec2 sRGBLines[] = { primR, primG, primB };
			for ( int i = 0; i < 3; ++i )
			{
				ImVec2& vCur = sRGBLines[ i ];

				vCur.x = curPos.x + ImRescale( vCur.x, minX, maxX, 0.0f, size.x );
				vCur.y = curPos.y + ImRescale( vCur.y, minY, maxY, size.y, 0.0f );
			}
			pDrawList->AddPolyline( &sRGBLines[ 0 ], 3, IM_COL32( 255, 255, 255, 255 ), true, 5.0f );
		}

		if ( showWhitePoint )
		{
			ImVec2 vWhitePoint = whitePoint;
			vWhitePoint.x = curPos.x + ImRescale( vWhitePoint.x, minX, maxX, 0.0f, size.x );
			vWhitePoint.y = curPos.y + ImRescale( vWhitePoint.y, minY, maxY, size.y, 0.0f );
			pDrawList->AddCircleFilled( vWhitePoint, 5.0f, IM_COL32( 0, 0, 0, 255 ), 4 );
		}

		if ( borderColor || showColorSpaceTriangle || showWhitePoint )
		{
			pDrawList->PopClipRect();
		}
	}

	void DrawChromaticityPlot( ImDrawList* pDrawList,
							   ImWidgetsIlluminance illum,
							   ImWidgetsObserver observer,
							   ImWidgetsColorSpace colorSpace,
							   int chromeLineSamplesCount,
							   ImVec2 const vpos, ImVec2 const size,
							   int resX, int resY,
							   ImU32 maskColor,
							   float wavelengthMin, float wavelengthMax,
							   float minX, float maxX,
							   float minY, float maxY,
							   bool showColorSpaceTriangle,
							   bool showWhitePoint,
							   bool showBorder,
							   ImU32 borderColor,
							   float borderThickness )
	{
		DrawChromaticityPlotGeneric(
			pDrawList,
			vpos,
			size,
			s_ColorSpace_Primaries[ colorSpace ][ 0 ], s_ColorSpace_Primaries[ colorSpace ][ 1 ], s_ColorSpace_Primaries[ colorSpace ][ 2 ],
			s_WhitePoints_Values[ s_ColorSpace_WhitePointIndex[ colorSpace ] ][ illum ],
			s_ColorSpace_XYZ2RGB[ colorSpace ],
			chromeLineSamplesCount,
			s_CIE_Observers_X[ observer ], s_CIE_Observers_Y[ observer ], s_CIE_Observers_Z[ observer ],
			s_CIE_Observers_SamplesCount[ observer ],
			s_CIE_Observers_min[ observer ], s_CIE_Observers_max[ observer ],
			s_Illums[ illum ],
			s_Illums_SamplesCount[ illum ],
			s_Illums_min[ illum ], s_Illums_max[ illum ],
			1.0f / s_ColorSpace_Gamma[ colorSpace ],
			resX, resY,
			maskColor,
			wavelengthMin, wavelengthMax,
			minX, maxX,
			minY, maxY,
			showColorSpaceTriangle,
			showWhitePoint,
			showBorder,
			borderColor,
			borderThickness );
	}

	void	DrawChromaticityPointsGeneric( ImDrawList* pDrawList,
										  ImVec2 curPos,
										  ImVec2 size,
										  float* rgbToXYZ,
										  float* colors4, // AoS: rgba, rgba, ...
										  int color_count,
										  float minX, float maxX,
										  float minY, float maxY,
										  ImU32 plotColor, float radius, int num_segments,
										  int colorStride )
	{
		ImRect clipRect( curPos, curPos + size );
		pDrawList->PushClipRect( clipRect.Min, clipRect.Max, true );
		float* current = colors4;
		for ( int i = 0; i < color_count; ++i )
		{
			float x, y, z;
			Mat33RowMajorMulVec3( x, y, z, rgbToXYZ, current );
			float sum = x + y + z;
			x /= sum;
			y /= sum;
			ImVec2 vCur;
			vCur.x = curPos.x + ImRescale( x, minX, maxX, 0.0f, size.x );
			vCur.y = curPos.y + ImRescale( y, minY, maxY, size.y, 0.0f );
			pDrawList->AddCircleFilled( vCur, radius, plotColor, num_segments );
			current += colorStride;
		}
		pDrawList->PopClipRect();
	}

	void DrawChromaticityPoints( ImDrawList* pDrawList,
								ImVec2 curPos,
								ImVec2 size,
								ImU32* colors,
								int color_count,
								float minX, float maxX,
								float minY, float maxY,
								ImU32 plotColor, float radius, int num_segments )
	{
		ImVector<float> colorsConverted;
		ImU32ColorToImRGBColor( colorsConverted, colors, color_count );
		DrawChromaticityPointsGeneric(
			pDrawList,
			curPos,
			size,
			s_ColorSpace_RGB2XYZ[ ImWidgetsColorSpace_sRGB ],
			&colorsConverted[ 0 ],
			color_count,
			minX, maxX,
			minY, maxY,
			plotColor, radius, num_segments,
			3 );
	}

	void DrawChromaticityPoints( ImDrawList* pDrawList,
								ImVec2 curPos,
								ImVec2 size,
								ImWidgetsColorSpace colorSpace,
								float* colors4, // AoS
								int color_count,
								float minX, float maxX,
								float minY, float maxY,
								ImU32 plotColor, float radius, int num_segments,
								int colorStride )
	{
		DrawChromaticityPointsGeneric(
			pDrawList,
			curPos,
			size,
			s_ColorSpace_RGB2XYZ[ ImWidgetsColorSpace_sRGB ],
			colors4,
			color_count,
			minX, maxX,
			minY, maxY,
			plotColor, radius, num_segments,
			colorStride );
	}

#pragma optimize( "", off )
	void	DrawChromaticityLinesGeneric( ImDrawList* pDrawList,
										  ImVec2 curPos,
										  ImVec2 size,
										  float* rgbToXYZ,
										  float* colors4, // AoS
										  int color_count,
										  float minX, float maxX,
										  float minY, float maxY,
										  ImU32 plotColor, ImDrawFlags flags, float thickness,
										  int colorStride )
	{
		ImRect clipRect( curPos, curPos + size );
		pDrawList->PushClipRect( clipRect.Min, clipRect.Max, true );
		ImVector<ImVec2> lines;
		lines.resize( color_count );
		float* current = colors4;
		for ( int k = 0; k < color_count; ++k )
		{
			float x, y, z;
			Mat33RowMajorMulVec3( x, y, z, rgbToXYZ, current );

			float sum = x + y + z;
			x /= sum;
			y /= sum;

			ImVec2 vCur;

			vCur.x = curPos.x + ImRescale( x, minX, maxX, 0.0f, size.x );
			vCur.y = curPos.y + ImRescale( y, minY, maxY, size.y, 0.0f );

			lines[ k ] = vCur;

			current += colorStride;
		}

		pDrawList->AddPolyline( &lines[ 0 ], color_count, plotColor, flags, thickness );
		pDrawList->PopClipRect();
	}

	void DrawChromaticityLines( ImDrawList* pDrawList,
								ImVec2 curPos,
								ImVec2 size,
								ImU32* colors,
								int color_count,
								float minX, float maxX,
								float minY, float maxY,
								ImU32 plotColor, ImDrawFlags flags, float thickness )
	{
		ImVector<float> colorsConverted;
		ImU32ColorToImRGBColor( colorsConverted, colors, color_count );
		DrawChromaticityLinesGeneric(
			pDrawList,
			curPos,
			size,
			s_ColorSpace_RGB2XYZ[ ImWidgetsColorSpace_sRGB ],
			&colorsConverted[ 0 ],
			color_count,
			minX, maxX,
			minY, maxY,
			plotColor, flags, thickness,
			3 );
	}

	void DrawChromaticityLines( ImDrawList* pDrawList,
								ImVec2 curPos,
								ImVec2 size,
								ImWidgetsColorSpace colorSpace,
								float* colors4,
								int color_count,
								float minX, float maxX,
								float minY, float maxY,
								ImU32 plotColor, ImDrawFlags flags, float thickness,
								int colorStride )
	{
		DrawChromaticityLinesGeneric(
			pDrawList,
			curPos,
			size,
			s_ColorSpace_RGB2XYZ[ ImWidgetsColorSpace_sRGB ],
			colors4,
			minX, maxX,
			minY, maxY,
			plotColor, flags, thickness,
			colorStride );
	}

	void ImDrawShapeConvex( ImDrawList* drawlist, ImVec2* pts, int pts_count, ImU32 col, float thickness )
	{
		drawlist->AddPolyline( pts, pts_count, col, 0, thickness );
	}
	void ImDrawShapeConcave( ImDrawList* drawlist, ImVec2* pts, int pts_count, ImU32 col, float thickness )
	{
		drawlist->AddPolyline( pts, pts_count, col, 0, thickness );
	}
	// TODO
	void ImDrawShapeWithHole( ImDrawList* drawlist, ImVec2* pts, int pts_count, ImU32 col, float thickness )
	{
		drawlist->AddPolyline( pts, pts_count, col, 0, thickness );
	}

	void ImDrawShapeConvexFilled( ImDrawList* drawlist, ImVec2* pts, int pts_count, ImU32 col )
	{
		drawlist->AddConvexPolyFilled( pts, pts_count, col );
	}
	void ImDrawShapeConcaveFilled( ImDrawList* drawlist, ImVec2* pts, int pts_count, ImU32 col  )
	{
		drawlist->AddConcavePolyFilled( pts, pts_count, col );
	}
	void ImDrawShapeWithHoleFilled( ImDrawList* drawlist, ImVec2* pts, int pts_count, ImU32 col )
	{
		DrawShapeWithHole( drawlist, pts, pts_count, col );
	}

	void DrawLinearLineGraduation( ImDrawList* drawlist, ImVec2 start, ImVec2 end,
							   float mainLineThickness, ImU32 mainCol,
							   int division0, float height0, float thickness0, float angle0, ImU32 col0,
							   int division1, float height1, float thickness1, float angle1, ImU32 col1,
							   int division2, float height2, float thickness2, float angle2, ImU32 col2 )
	{
		if ( mainLineThickness < 0.5f ||
			 ( thickness0 < 0.5f &&
			   thickness1 < 0.5f &&
			   thickness2 < 0.5f ) )
			return;
		if ( ( mainCol & IM_COL32_A_MASK ) == 0 &&
			 ( ( col0 | col1 | col2 ) & IM_COL32_A_MASK ) == 0 )
			return;

		ImVec2 delta = end - start;
		float length = ImLength( delta );
		ImVec2 forward = ImNormalized( delta );
		ImVec2 up = ImAntiHalfTurn( forward );
		if ( division0 > 0 )
		{
			float dx0 = length / ( ( float )division0 );
			float inv_div0 = 1.0f / ( ( float )division0 );
			ImVec2 up0;
			if ( angle0 != 0.0f )
			{
				float cos0 = ImCos( -angle0 );
				float sin0 = ImSin( -angle0 );
				up0 = ImRotate( up, cos0, sin0 );
			}
			else
			{
				up0 = up;
			}
			for ( int k = 0; k <= division0; ++k )
			{
				float fk = ( float )k;
				float t = fk * inv_div0;
				ImVec2 v = ImLerp( start, end, t );
				drawlist->AddLine( v, v + up0 * height0, col0, thickness0 );
			}
		}
		if ( division0 > 0 && division1 > 0 )
		{
			float dx0 = length / ( ( float )division0 );
			float inv_div0 = 1.0f / ( ( float )division0 );
			float dx1 = dx0 / ( ( float )division1 );
			float inv_div1 = 1.0f / ( ( float )division1 );
			ImVec2 up1;
			if ( angle1 != 0.0f )
			{
				float cos0 = ImCos( -angle1 );
				float sin0 = ImSin( -angle1 );
				up1 = ImRotate( up, cos0, sin0 );
			}
			else
			{
				up1 = up;
			}
			for ( int p = 0; p < division0; ++p )
			{
				float fp = ( float )p;
				float t0 = fp * inv_div0;
				ImVec2 v0 = ImLerp( start, end, t0 );
				for ( int k = 1; k < division1; ++k )
				{
					float fk = ( float )k;
					float t1 = fk * inv_div1;
					ImVec2 v = v0 + forward * (fk * dx1);
					drawlist->AddLine( v, v + up1 * height1, col1, thickness1 );
				}
			}
		}
		if ( division0 > 0 && division1 > 0 && division2 > 0 )
		{
			float dx0 = length / ( ( float )division0 );
			float inv_div0 = 1.0f / ( ( float )division0 );
			float dx1 = dx0 / ( ( float )division1 );
			float inv_div1 = 1.0f / ( ( float )division1 );
			float dx2 = dx1 / ( ( float )division2 );
			float inv_div2 = 1.0f / ( ( float )division2 );
			ImVec2 up2;
			if ( angle2 != 0.0f )
			{
				float cos0 = ImCos( -angle2 );
				float sin0 = ImSin( -angle2 );
				up2 = ImRotate( up, cos0, sin0 );
			}
			else
			{
				up2 = up;
			}
			for ( int p = 0; p < division0; ++p )
			{
				float fp = ( float )p;
				float t0 = fp * inv_div0;
				ImVec2 v0 = ImLerp( start, end, t0 );
				for ( int q = 0; q < division1; ++q )
				{
					float fk = ( float )q;
					ImVec2 v1 = v0 + forward * (fk * dx1);
					for ( int k = 1; k < division2; ++k )
					{
						float fk = ( float )k;
						ImVec2 v = v1 + forward * ( fk * dx2 );
						drawlist->AddLine( v, v + up2 * height2, col2, thickness2 );
					}
				}
			}
		}
		drawlist->AddLine( start, end, mainCol, mainLineThickness );
	}

	void DrawLinearCircularGraduation( ImDrawList* drawlist, ImVec2 center, float radius, float start_angle, float end_angle, int num_segments,
							   float mainLineThickness, ImU32 mainCol,
							   int division0, float height0, float thickness0, float angle0, ImU32 col0,
							   int division1, float height1, float thickness1, float angle1, ImU32 col1,
							   int division2, float height2, float thickness2, float angle2, ImU32 col2 )
	{
		if ( radius < 0.5f ||
			( thickness0 < 0.5f &&
			 thickness1 < 0.5f &&
			 thickness2 < 0.5f ) )
			return;
		if ( ( mainCol & IM_COL32_A_MASK ) == 0 &&
			 ( ( col0 | col1 | col2 ) & IM_COL32_A_MASK ) == 0 )
			return;


		if ( start_angle > end_angle )
		{
			while ( start_angle > end_angle )
			{
				start_angle += 2.0f * IM_PI;
			}
		}
		float angle_spread = end_angle - start_angle;
		ImVec2 up = ImRotate( ImVec2( 1.0f, 0.0f ), ImCos( start_angle ), ImSin( start_angle ) );
		if ( division0 > 0 )
		{
			float da0 = angle_spread / ( ( float )division0 );
			for ( int k = 0; k <= division0; ++k )
			{
				float fk = ( float )k;
				float a0 = start_angle + fk * da0;
				float a1 = a0 + angle0;
				float cos00 = ImCos( -a0 );
				float sin00 = ImSin( -a0 );
				float cos01 = ImCos( -a1 );
				float sin01 = ImSin( -a1 );
				ImVec2 up0 = ImRotate( ImVec2( 1.0f, 0.0f ), cos00, sin00 );
				ImVec2 up1 = ImRotate( ImVec2( 1.0f, 0.0f ), cos01, sin01 );
				ImVec2 v = center + up0 * radius;
				drawlist->AddLine( v, v + up1 * height0, col0, thickness0 );
			}
		}
		if ( division0 > 0 && division1 > 0 )
		{
			float da0 = angle_spread / ( ( float )division0 );
			float da1 = da0 / ( ( float )division1 );
			for ( int p = 0; p < division0; ++p )
			{
				float fp = ( float )p;
				float ap = start_angle + fp * da0;
				for ( int k = 1; k < division1; ++k )
				{
					float fk = ( float )k;
					float a0 = ap + fk * da1;
					float a1 = a0 + angle1;
					float cos00 = ImCos( -a0 );
					float sin00 = ImSin( -a0 );
					float cos01 = ImCos( -a1 );
					float sin01 = ImSin( -a1 );
					ImVec2 up0 = ImRotate( ImVec2( 1.0f, 0.0f ), cos00, sin00 );
					ImVec2 up1 = ImRotate( ImVec2( 1.0f, 0.0f ), cos01, sin01 );
					ImVec2 v = center + up0 * radius;
					drawlist->AddLine( v, v + up1 * height1, col1, thickness1 );
				}
			}
		}
		if ( division0 > 0 && division1 > 0 && division2 > 0 )
		{
			float da0 = angle_spread / ( ( float )division0 );
			float da1 = da0 / ( ( float )division1 );
			float da2 = da1 / ( ( float )division2 );
			for ( int p = 0; p < division0; ++p )
			{
				float fp = ( float )p;
				float ap = start_angle + fp * da0;
				for ( int q = 0; q < division1; ++q )
				{
					float fq = ( float )q;
					float aq = ap + fq * da1;
					for ( int k = 1; k < division2; ++k )
					{
						float fk = ( float )k;
						float a0 = aq + fk * da2;
						float a1 = a0 + angle2;
						float cos00 = ImCos( -a0 );
						float sin00 = ImSin( -a0 );
						float cos01 = ImCos( -a1 );
						float sin01 = ImSin( -a1 );
						ImVec2 up0 = ImRotate( ImVec2( 1.0f, 0.0f ), cos00, sin00 );
						ImVec2 up1 = ImRotate( ImVec2( 1.0f, 0.0f ), cos01, sin01 );
						ImVec2 v = center + up0 * radius;
						drawlist->AddLine( v, v + up1 * height2, col2, thickness2 );
					}
				}
			}
		}

		drawlist->PathArcTo( center, radius, -start_angle, -end_angle, num_segments );
		drawlist->PathStroke( mainCol, ImDrawFlags_None, mainLineThickness );
	}

	void DrawLogLineGraduation( ImDrawList* drawlist, ImVec2 start, ImVec2 end,
								float mainLineThickness, ImU32 mainCol,
								int division0, float height0, float thickness0, float angle0, ImU32 col0,
								int division1, float height1, float thickness1, float angle1, ImU32 col1 )
	{
		if ( mainLineThickness < 0.5f ||
			 ( thickness0 < 0.5f &&
			   thickness1 < 0.5f ) )
			return;
		if ( ( mainCol & IM_COL32_A_MASK ) == 0 &&
				( ( col0 | col1 ) & IM_COL32_A_MASK ) == 0 )
			return;

		ImVec2 delta = end - start;
		float length = ImLength( delta );
		ImVec2 forward = ImNormalized( delta );
		ImVec2 up = ImAntiHalfTurn( forward );
		if ( division0 > 0 )
		{
			float dx0 = length / ( ( float )division0 );
			float inv_div0 = 1.0f / ( ( float )division0 );
			ImVec2 up0;
			if ( angle0 != 0.0f )
			{
				float cos0 = ImCos( -angle0 );
				float sin0 = ImSin( -angle0 );
				up0 = ImRotate( up, cos0, sin0 );
			}
			else
			{
				up0 = up;
			}
			for ( int k = 0; k <= division0; ++k )
			{
				float fk = ( float )k;
				float t = fk * inv_div0;
				ImVec2 v = ImLerp( start, end, t );
				drawlist->AddLine( v, v + up0 * height0, col0, thickness0 );
			}
		}
		if ( division0 > 0 && division1 > 0 )
		{
			float dx0 = length / ( ( float )division0 );
			float inv_div0 = 1.0f / ( ( float )division0 );
			float dx1 = dx0 / ( ( float )division1 );
			float inv_div1 = 1.0f / ( ( float )division1 );
			float scale = 1.0f / ImLog( ( float )( division1 + 1 ) );
			ImVec2 up1;
			if ( angle1 != 0.0f )
			{
				float cos0 = ImCos( -angle1 );
				float sin0 = ImSin( -angle1 );
				up1 = ImRotate( up, cos0, sin0 );
			}
			else
			{
				up1 = up;
			}
			for ( int p = 0; p < division0; ++p )
			{
				float fp = ( float )p;
				float t0 = fp * inv_div0;
				ImVec2 v0 = ImLerp( start, end, t0 );
				for ( int k = 2; k < division1 + 1; ++k )
				{
					float fk = ImLog( ( float )( k ) ) * scale;
					ImVec2 v = v0 + forward * ( fk * dx0 );
					drawlist->AddLine( v, v + up1 * height1, col1, thickness1 );
				}
			}
		}

		drawlist->AddLine( start, end, mainCol, mainLineThickness );
	}

	void DrawLogCircularGraduation( ImDrawList* drawlist, ImVec2 center, float radius, float start_angle, float end_angle, int num_segments,
									float mainLineThickness, ImU32 mainCol,
									int division0, float height0, float thickness0, float angle0, ImU32 col0,
									int division1, float height1, float thickness1, float angle1, ImU32 col1 )
	{
		if ( radius < 0.5f ||
			 ( thickness0 < 0.5f &&
			   thickness1 < 0.5f ) )
			return;
		if ( ( mainCol & IM_COL32_A_MASK ) == 0 &&
				( ( col0 | col1 ) & IM_COL32_A_MASK ) == 0 )
			return;


		if ( start_angle > end_angle )
		{
			while ( start_angle > end_angle )
			{
				start_angle += 2.0f * IM_PI;
			}
		}
		float angle_spread = end_angle - start_angle;
		ImVec2 up = ImRotate( ImVec2( 1.0f, 0.0f ), ImCos( start_angle ), ImSin( start_angle ) );
		if ( division0 > 0 )
		{
			float da0 = angle_spread / ( ( float )division0 );
			for ( int k = 0; k <= division0; ++k )
			{
				float fk = ( float )k;
				float a0 = start_angle + fk * da0;
				float a1 = a0 + angle0;
				float cos00 = ImCos( -a0 );
				float sin00 = ImSin( -a0 );
				float cos01 = ImCos( -a1 );
				float sin01 = ImSin( -a1 );
				ImVec2 up0 = ImRotate( ImVec2( 1.0f, 0.0f ), cos00, sin00 );
				ImVec2 up1 = ImRotate( ImVec2( 1.0f, 0.0f ), cos01, sin01 );
				ImVec2 v = center + up0 * radius;
				drawlist->AddLine( v, v + up1 * height0, col0, thickness0 );
			}
		}
		if ( division0 > 0 && division1 > 0 )
		{
			float da0 = angle_spread / ( ( float )division0 );
			float da1 = da0 / ( ( float )division1 );
			float scale = 1.0f / ImLog( ( float )( division1 + 1 ) );
			for ( int p = 0; p < division0; ++p )
			{
				float fp = ( float )p;
				float ap = start_angle + fp * da0;

				for ( int k = 2; k < division1 + 1; ++k )
				{
					float fk = ImLog( ( float )( k ) ) * scale;
					float a0 = ap + fk * da0;

					float a1 = a0 + angle1;
					float cos00 = ImCos( -a0 );
					float sin00 = ImSin( -a0 );
					float cos01 = ImCos( -a1 );
					float sin01 = ImSin( -a1 );
					ImVec2 up0 = ImRotate( ImVec2( 1.0f, 0.0f ), cos00, sin00 );
					ImVec2 up1 = ImRotate( ImVec2( 1.0f, 0.0f ), cos01, sin01 );
					ImVec2 v = center + up0 * radius;
					drawlist->AddLine( v, v + up1 * height1, col1, thickness1 );
				}
			}
		}

		drawlist->PathArcTo( center, radius, -start_angle, -end_angle, num_segments );
		drawlist->PathStroke( mainCol, ImDrawFlags_None, mainLineThickness );
	}

	void RenderNavHighlightShape( ImVec2* pts, int pts_count, ImGuiID id, ImGuiNavHighlightFlags flags, ImDrawShape func )
	{
		ImGuiContext& g = *GImGui;
		if ( id != g.NavId )
			return;
		if ( g.NavDisableHighlight && !( flags & ImGuiNavHighlightFlags_AlwaysDraw ) )
			return;
		ImGuiWindow* window = g.CurrentWindow;
		if ( window->DC.NavHideHighlightOneFrame )
			return;

		float rounding = ( flags & ImGuiNavHighlightFlags_NoRounding ) ? 0.0f : g.Style.FrameRounding;
		ImRect display_rect;
		ImComputeRect( &display_rect, pts, pts_count );
		display_rect.ClipWith( window->ClipRect );
		const float thickness = 2.0f;
		if ( flags & ImGuiNavHighlightFlags_Compact )
		{
			func( window->DrawList, pts, pts_count, ImGui::GetColorU32( ImGuiCol_NavHighlight ), thickness );
		}
		else
		{
			const float distance = 3.0f + thickness * 0.5f;
			display_rect.Expand( ImVec2( distance, distance ) );
			bool fully_visible = window->ClipRect.Contains( display_rect );
			if ( !fully_visible )
				window->DrawList->PushClipRect( display_rect.Min, display_rect.Max );
			func( window->DrawList, pts, pts_count, ImGui::GetColorU32( ImGuiCol_NavHighlight ), thickness );
			if ( !fully_visible )
				window->DrawList->PopClipRect();
		}
	}
	void RenderNavHighlightConvex( ImVec2* pts, int pts_count, ImGuiID id, ImGuiNavHighlightFlags flags )
	{
		RenderNavHighlightShape( pts, pts_count, id, flags, &ImDrawShapeConvex );
	}
	void RenderNavHighlightConcave( ImVec2* pts, int pts_count, ImGuiID id, ImGuiNavHighlightFlags flags )
	{
		RenderNavHighlightShape( pts, pts_count, id, flags, &ImDrawShapeConcave );
	}
	void RenderNavHighlightWithHole( ImVec2* pts, int pts_count, ImGuiID id, ImGuiNavHighlightFlags flags )
	{
		RenderNavHighlightShape( pts, pts_count, id, flags, &ImDrawShapeWithHole );
	}

	void RenderFrameShape( ImVec2* pts, int pts_count, ImU32 fill_col, bool border, ImDrawShape outline, ImDrawShapeFilled fill )
	{
		ImGuiContext& g = *GImGui;
		ImGuiWindow* window = g.CurrentWindow;
		fill( window->DrawList, pts, pts_count, fill_col );
		const float border_size = g.Style.FrameBorderSize;
		if ( border && border_size > 0.0f )
		{
			// TODO add offset to the draw functions or "WithOffset" functions
			ImVector<ImVec2> shadow;
			shadow.resize(pts_count);
			for ( int k = 0; k < pts_count; ++k )
			{
				shadow[ k ] = pts[ k ] + ImVec2( 1.0f, 1.0f );
			}
			outline( window->DrawList, &shadow[ 0 ], pts_count, ImGui::GetColorU32(ImGuiCol_BorderShadow), border_size);
			//
			outline( window->DrawList, pts, pts_count, ImGui::GetColorU32( ImGuiCol_Border ), border_size );
		}
	}
	void RenderFrameConcave( ImVec2* pts, int pts_count, ImU32 fill_col, bool border )
	{
		RenderFrameShape( pts, pts_count, fill_col, border, ImDrawShapeConvex, ImDrawShapeConvexFilled );
	}
	void RenderFrameConvex( ImVec2* pts, int pts_count, ImU32 fill_col, bool border )
	{
		RenderFrameShape( pts, pts_count, fill_col, border, ImDrawShapeConcave, ImDrawShapeConcaveFilled );
	}
	void RenderFrameWithHole( ImVec2* pts, int pts_count, ImU32 fill_col, bool border )
	{
		RenderFrameShape( pts, pts_count, fill_col, border, ImDrawShapeWithHole, ImDrawShapeWithHoleFilled );
	}
	//////////////////////////////////////////////////////////////////////////
	// Interactions
	//////////////////////////////////////////////////////////////////////////
	bool IsTriangleContains( ImVec2 a, ImVec2 b, ImVec2 c, ImVec2 p )
	{
		// Compute vectors
		ImVec2 v0 = { c.x - a.x, c.y - a.y };
		ImVec2 v1 = { b.x - a.x, b.y - a.y };
		ImVec2 v2 = { p.x - a.x, p.y - a.y };

		// Compute dot products
		float dot00 = v0.x * v0.y + v0.y * v0.y;
		float dot01 = v0.x * v1.x + v0.y * v1.y;
		float dot02 = v0.x * v2.x + v0.y * v2.y;
		float dot11 = v1.x * v1.x + v1.y * v1.y;
		float dot12 = v1.x * v2.x + v1.y * v2.y;

		// Compute barycentric coordinates
		float invDenom = 1.0f / ( dot00 * dot11 - dot01 * dot01 );
		float u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		float v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// Check if point is in triangle
		return ( u >= 0.0f ) && ( v >= 0.0f ) && ( u + v < 1.0f );
	}

	bool IsPolyConvexContains( ImVec2* pts, int pts_count, ImVec2 p )
	{
		IM_ASSERT( pts_count >= 3 );

		for ( int k = 2; k < pts_count; ++k )
		{
			ImVec2 a = pts[ 0 ];
			ImVec2 b = pts[ k - 1 ];
			ImVec2 c = pts[ k ];
			if ( ImTriangleContainsPoint( a, b, c, p ) )
				return true;
		}

		return false;
	}

	bool IsPolyConcaveContains( ImVec2* pts, int pts_count, ImVec2 p )
	{
		IM_ASSERT( pts_count >= 3 );

		ImRect bb;
		bb.Min = ImVec2( FLT_MAX, FLT_MAX );
		bb.Max = ImVec2( -FLT_MAX, -FLT_MAX );
		for ( int k = 0; k < pts_count; ++k )
		{
			bb.Min.x = ImMin( bb.Min.x, pts[ k ].x );
			bb.Min.y = ImMin( bb.Min.y, pts[ k ].y );
			bb.Max.x = ImMax( bb.Max.x, pts[ k ].x );
			bb.Max.y = ImMax( bb.Max.y, pts[ k ].y );
		}
		if ( !bb.ContainsWithPad( p, ImVec2( 1.0f, 1.0f ) ) )
			return false;

		ImDrawListSharedData* _Data = ImGui::GetCurrentWindow()->DrawList->_Data;

		ImTriangulator0 triangulator;
		unsigned int triangle[ 3 ];
		{
			// Non Anti-aliased Fill
			const int idx_count = ( pts_count - 2 ) * 3;
			triangulator.Init( pts, pts_count, _Data->TempBuffer.Data );
			while ( triangulator._TrianglesLeft > 0 )
			{
				triangulator.GetNextTriangle( triangle );
				if ( ImTriangleContainsPoint( pts[ triangle[ 0 ] ], pts[ triangle[ 1 ] ], pts[ triangle[ 2 ] ], p ) )
					return true;
			}
		}

		return false;
	}

	bool IsPolyWithHoleContains( ImVec2* pts, int pts_count, ImVec2 p, ImRect* p_bb, int gap, int strokeWidth )
	{
		ImVector<ImVec2> scanHits;
		ImVec2 min, max; // polygon min/max points
		float y;
		bool isMinMaxDone = false;

		// find the orthagonal bounding box
		// probably can put this as a predefined
		if ( !isMinMaxDone )
		{
			min.x = min.y = FLT_MAX;
			max.x = max.y = FLT_MIN;
			//for ( auto p : poly )
			for ( int i = 0; i < pts_count; ++i )
			{
				ImVec2 p = pts[ i ];
				if ( p.x < min.x )
					min.x = p.x;
				if ( p.y < min.y )
					min.y = p.y;
				if ( p.x > max.x )
					max.x = p.x;
				if ( p.y > max.y )
					max.y = p.y;
			}
			isMinMaxDone = true;
		}
		ImRect bb;
		if ( p_bb == NULL )
		{
			bb.Min = min;
			bb.Max = max;
		}
		else
		{
			bb = *p_bb;
		}
		if ( !bb.ContainsWithPad( p, ImVec2( 1.0f, 1.0f ) ) )
			return false;

		// Bounds check
		if ( ( max.x < 0 ) || ( max.y < 0 ) )
			return false;

		// Vertically clip
		if ( min.y <= 0 )
			min.y = 0;

		// so we know we start on the outside of the object we step out by 1.
		min.x -= 1;
		max.x += 1;

		// Initialise our starting conditions
		y = min.y;

		struct ImVec2CompX
		{
			static int IMGUI_CDECL Comp( const void* lhs, const void* rhs )
			{
				if ( ( ( const ImVec2* )lhs )->x > ( ( const ImVec2* )rhs )->x )
					return +1;
				if ( ( ( const ImVec2* )lhs )->x < ( ( const ImVec2* )rhs )->x )
					return -1;
				return 0;
			}
		};

		while ( y < max.y )
		{
			scanHits.clear();
			{
				int jump = 1;
				ImVec2 fp = pts[ 0 ];

				for ( size_t i = 0; i < pts_count - 1; i++ )
				{
					ImVec2 pa = pts[ i ];
					ImVec2 pb = pts[ i + 1 ];

					// jump double/dud points
					if ( pa.x == pb.x && pa.y == pb.y ) continue;

					// if we encounter our hull/poly start point, then we've now created the
					// closed
					// hull, jump the next segment and reset the first-point
					if ( ( !jump ) && ( fp.x == pb.x ) && ( fp.y == pb.y ) )
					{
						if ( i < pts_count - 2 )
						{
							fp = pts[ i + 2 ];
							jump = 1;
							i++;
						}
					}
					else
					{
						jump = 0;
					}

					// test to see if this segment makes the scan-cut.
					if ( ( pa.y > pb.y && y < pa.y && y > pb.y ) || ( pa.y < pb.y && y > pa.y && y < pb.y ) )
					{
						ImVec2 intersect;

						intersect.y = y;
						if ( pa.x == pb.x )
						{
							intersect.x = pa.x;
						}
						else
						{
							intersect.x = ( pb.x - pa.x ) / ( pb.y - pa.y ) * ( y - pa.y ) + pa.x;
						}
						scanHits.push_back( intersect );
					}
				}

				// Sort the scan hits by X, so we have a proper left->right ordering
				ImQsort( &scanHits[ 0 ], scanHits.size(), sizeof( ImVec2 ), &ImVec2CompX::Comp );

				// generate the line segments.
				int i = 0;
				int l = scanHits.size() - 1; // we need pairs of points, this prevents segfault.
				for ( i = 0; i < l; i += 2 )
				{
					ImVec2 a = scanHits[ i ];
					ImVec2 b = scanHits[ i + 1 ];
					if ( ImRect( a, b ).ContainsWithPad( p, ImVec2( 0.0f, ( float )strokeWidth ) ) )
					{
						scanHits.clear();
						return true;
					}
				}
			}
			y += gap;
		}

		return false;
	}

	bool IsMouseHoveringPolyConvex( const ImVec2& r_min, const ImVec2& r_max, ImVec2* pts, int pts_count, bool clip )
	{
		bool well_form = true;
		for ( int k = 0; k < pts_count; ++k )
		{
			well_form &= ImRect( r_min, r_max ).Contains( pts[ k ] );
		}
		IM_ASSERT( well_form );

		ImGuiContext& g = *ImGui::GetCurrentContext();

		// Clip
		ImRect rect_clipped( r_min, r_max );
		if ( clip )
			rect_clipped.ClipWith( g.CurrentWindow->ClipRect );

		// Hit testing, expanded for touch input
		if ( !rect_clipped.ContainsWithPad( g.IO.MousePos, g.Style.TouchExtraPadding ) )
			return false;
		if ( !IsPolyConvexContains( pts, pts_count, g.IO.MousePos ) )
			return false;

		return true;
	}

	bool ItemHoverablePolyConvex( const ImRect& bb, ImGuiID id, ImVec2* pts, int pts_count, ImGuiItemFlags item_flags )
	{
		ImGuiContext& g = *GImGui;
		ImGuiWindow* window = g.CurrentWindow;

		bool well_form = true;
		for ( int k = 0; k < pts_count; ++k )
		{
			well_form &= bb.Contains( pts[ k ] );
		}
		IM_ASSERT( well_form );

		if ( g.HoveredWindow != window )
			return false;
		if ( !ImGui::IsMouseHoveringRect( bb.Min, bb.Max ) )
			return false;
		if ( !IsMouseHoveringPolyConvex( bb.Min, bb.Max, pts, pts_count ) )
			return false;

		if ( g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap )
			return false;
		if ( g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap )
			if ( !g.ActiveIdFromShortcut )
				return false;

		// Done with rectangle culling so we can perform heavier checks now.
		if ( !( item_flags & ImGuiItemFlags_NoWindowHoverableCheck ) && !ImGui::IsWindowContentHoverable( window, ImGuiHoveredFlags_None ) )
		{
			g.HoveredIdIsDisabled = true;
			return false;
		}

		// We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
		// hover test in widgets code. We could also decide to split this function is two.
		if ( id != 0 )
		{
			// Drag source doesn't report as hovered
			if ( g.DragDropActive && g.DragDropPayload.SourceId == id && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover ) )
				return false;

			ImGui::SetHoveredID( id );

			// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
			// This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
			if ( item_flags & ImGuiItemFlags_AllowOverlap )
			{
				g.HoveredIdAllowOverlap = true;
				if ( g.HoveredIdPreviousFrame != id )
					return false;
			}

			// Display shortcut (only works with mouse)
			if ( id == g.LastItemData.ID && ( g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut ) )
				if ( ImGui::IsItemHovered( ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal ) )
					ImGui::SetTooltip( "%s", ImGui::GetKeyChordName( g.LastItemData.Shortcut ) );
		}

		// When disabled we'll return false but still set HoveredId
		if ( item_flags & ImGuiItemFlags_Disabled )
		{
			// Release active id if turning disabled
			if ( g.ActiveId == id && id != 0 )
				ImGui::ClearActiveID();
			g.HoveredIdIsDisabled = true;
			return false;
		}

#ifndef IMGUI_DISABLE_DEBUG_TOOLS
		if ( id != 0 )
		{
			// [DEBUG] Item Picker tool!
			// We perform the check here because reaching is path is rare (1~ time a frame),
			// making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
			// items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
			if ( g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id )
				ImGui::GetForegroundDrawList()->AddRect( bb.Min, bb.Max, IM_COL32( 255, 255, 0, 255 ) );
			if ( g.DebugItemPickerBreakId == id )
				IM_DEBUG_BREAK();
		}
#endif

		if ( g.NavDisableMouseHover )
			return false;

		return true;
	}

	bool IsMouseHoveringPolyConcave( const ImVec2& r_min, const ImVec2& r_max, ImVec2* pts, int pts_count, bool clip )
	{
		bool well_form = true;
		for ( int k = 0; k < pts_count; ++k )
		{
			well_form &= ImRect( r_min, r_max ).Contains( pts[ k ] );
		}
		IM_ASSERT( well_form );

		ImGuiContext& g = *ImGui::GetCurrentContext();

		// Clip
		ImRect rect_clipped( r_min, r_max );
		if ( clip )
			rect_clipped.ClipWith( g.CurrentWindow->ClipRect );

		// Hit testing, expanded for touch input
		if ( !rect_clipped.ContainsWithPad( g.IO.MousePos, g.Style.TouchExtraPadding ) )
			return false;
		if ( !IsPolyConcaveContains( pts, pts_count, g.IO.MousePos ) )
			return false;

		return true;
	}

	bool ItemHoverablePolyConcave( const ImRect& bb, ImGuiID id, ImVec2* pts, int pts_count, ImGuiItemFlags item_flags )
	{
		ImGuiContext& g = *GImGui;
		ImGuiWindow* window = g.CurrentWindow;

		bool well_form = true;
		for ( int k = 0; k < pts_count; ++k )
		{
			well_form &= bb.Contains( pts[ k ] );
		}
		IM_ASSERT( well_form );

		if ( g.HoveredWindow != window )
			return false;
		if ( !ImGui::IsMouseHoveringRect( bb.Min, bb.Max ) )
			return false;
		if ( !IsMouseHoveringPolyConcave( bb.Min, bb.Max, pts, pts_count ) )
			return false;

		if ( g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap )
			return false;
		if ( g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap )
			if ( !g.ActiveIdFromShortcut )
				return false;

		// Done with rectangle culling so we can perform heavier checks now.
		if ( !( item_flags & ImGuiItemFlags_NoWindowHoverableCheck ) && !ImGui::IsWindowContentHoverable( window, ImGuiHoveredFlags_None ) )
		{
			g.HoveredIdIsDisabled = true;
			return false;
		}

		// We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
		// hover test in widgets code. We could also decide to split this function is two.
		if ( id != 0 )
		{
			// Drag source doesn't report as hovered
			if ( g.DragDropActive && g.DragDropPayload.SourceId == id && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover ) )
				return false;

			ImGui::SetHoveredID( id );

			// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
			// This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
			if ( item_flags & ImGuiItemFlags_AllowOverlap )
			{
				g.HoveredIdAllowOverlap = true;
				if ( g.HoveredIdPreviousFrame != id )
					return false;
			}

			// Display shortcut (only works with mouse)
			if ( id == g.LastItemData.ID && ( g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut ) )
				if ( ImGui::IsItemHovered( ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal ) )
					ImGui::SetTooltip( "%s", ImGui::GetKeyChordName( g.LastItemData.Shortcut ) );
		}

		// When disabled we'll return false but still set HoveredId
		if ( item_flags & ImGuiItemFlags_Disabled )
		{
			// Release active id if turning disabled
			if ( g.ActiveId == id && id != 0 )
				ImGui::ClearActiveID();
			g.HoveredIdIsDisabled = true;
			return false;
		}

#ifndef IMGUI_DISABLE_DEBUG_TOOLS
		if ( id != 0 )
		{
			// [DEBUG] Item Picker tool!
			// We perform the check here because reaching is path is rare (1~ time a frame),
			// making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
			// items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
			if ( g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id )
				ImGui::GetForegroundDrawList()->AddRect( bb.Min, bb.Max, IM_COL32( 255, 255, 0, 255 ) );
			if ( g.DebugItemPickerBreakId == id )
				IM_DEBUG_BREAK();
		}
#endif

		if ( g.NavDisableMouseHover )
			return false;

		return true;
	}

	bool IsMouseHoveringPolyWithHole( const ImVec2& r_min, const ImVec2& r_max, ImVec2* pts, int pts_count, bool clip )
	{
		bool well_form = true;
		for ( int k = 0; k < pts_count; ++k )
		{
			well_form &= ImRect( r_min, r_max ).Contains( pts[ k ] );
		}
		IM_ASSERT( well_form );

		ImGuiContext& g = *ImGui::GetCurrentContext();

		// Clip
		ImRect rect_clipped( r_min, r_max );
		if ( clip )
			rect_clipped.ClipWith( g.CurrentWindow->ClipRect );

		// Hit testing, expanded for touch input
		if ( !rect_clipped.ContainsWithPad( g.IO.MousePos, g.Style.TouchExtraPadding ) )
			return false;
		if ( !IsPolyWithHoleContains( pts, pts_count, g.IO.MousePos ) )
			return false;

		return true;
	}

	bool ItemHoverablePolyWithHole( const ImRect& bb, ImGuiID id, ImVec2* pts, int pts_count, ImGuiItemFlags item_flags )
	{
		ImGuiContext& g = *GImGui;
		ImGuiWindow* window = g.CurrentWindow;

		bool well_form = true;
		for ( int k = 0; k < pts_count; ++k )
		{
			well_form &= bb.Contains( pts[ k ] );
		}
		IM_ASSERT( well_form );

		if ( g.HoveredWindow != window )
			return false;
		if ( !ImGui::IsMouseHoveringRect( bb.Min, bb.Max ) )
			return false;
		if ( !IsMouseHoveringPolyWithHole( bb.Min, bb.Max, pts, pts_count ) )
			return false;

		if ( g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap )
			return false;
		if ( g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap )
			if ( !g.ActiveIdFromShortcut )
				return false;

		// Done with rectangle culling so we can perform heavier checks now.
		if ( !( item_flags & ImGuiItemFlags_NoWindowHoverableCheck ) && !ImGui::IsWindowContentHoverable( window, ImGuiHoveredFlags_None ) )
		{
			g.HoveredIdIsDisabled = true;
			return false;
		}

		// We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
		// hover test in widgets code. We could also decide to split this function is two.
		if ( id != 0 )
		{
			// Drag source doesn't report as hovered
			if ( g.DragDropActive && g.DragDropPayload.SourceId == id && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover ) )
				return false;

			ImGui::SetHoveredID( id );

			// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
			// This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
			if ( item_flags & ImGuiItemFlags_AllowOverlap )
			{
				g.HoveredIdAllowOverlap = true;
				if ( g.HoveredIdPreviousFrame != id )
					return false;
			}

			// Display shortcut (only works with mouse)
			if ( id == g.LastItemData.ID && ( g.LastItemData.StatusFlags & ImGuiItemStatusFlags_HasShortcut ) )
				if ( ImGui::IsItemHovered( ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal ) )
					ImGui::SetTooltip( "%s", ImGui::GetKeyChordName( g.LastItemData.Shortcut ) );
		}

		// When disabled we'll return false but still set HoveredId
		if ( item_flags & ImGuiItemFlags_Disabled )
		{
			// Release active id if turning disabled
			if ( g.ActiveId == id && id != 0 )
				ImGui::ClearActiveID();
			g.HoveredIdIsDisabled = true;
			return false;
		}

#ifndef IMGUI_DISABLE_DEBUG_TOOLS
		if ( id != 0 )
		{
			// [DEBUG] Item Picker tool!
			// We perform the check here because reaching is path is rare (1~ time a frame),
			// making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
			// items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
			if ( g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id )
				ImGui::GetForegroundDrawList()->AddRect( bb.Min, bb.Max, IM_COL32( 255, 255, 0, 255 ) );
			if ( g.DebugItemPickerBreakId == id )
				IM_DEBUG_BREAK();
		}
#endif

		if ( g.NavDisableMouseHover )
			return false;

		return true;
	}

	bool ButtonBehaviorShape( ImVec2* pts, int pts_count, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags, ImItemHoverablePolyConvexFunc func )
	{
		// Copy Past from ImGui::ButtonBehavior to only change ItemHovered
		ImGuiContext& g = *GImGui;
		ImGuiWindow* window = ImGui::GetCurrentWindow();

		// Default only reacts to left mouse button
		if ( ( flags & ImGuiButtonFlags_MouseButtonMask_ ) == 0 )
			flags |= ImGuiButtonFlags_MouseButtonLeft;

		// Default behavior requires click + release inside bounding box
		if ( ( flags & ImGuiButtonFlags_PressedOnMask_ ) == 0 )
			flags |= ImGuiButtonFlags_PressedOnDefault_;

		// Default behavior inherited from item flags
		// Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.
		ImGuiItemFlags item_flags = ( g.LastItemData.ID == id ? g.LastItemData.InFlags : g.CurrentItemFlags );
		if ( flags & ImGuiButtonFlags_AllowOverlap )
			item_flags |= ImGuiItemFlags_AllowOverlap;
		if ( flags & ImGuiButtonFlags_Repeat )
			item_flags |= ImGuiItemFlags_ButtonRepeat;

		ImGuiWindow* backup_hovered_window = g.HoveredWindow;
		const bool flatten_hovered_children = ( flags & ImGuiButtonFlags_FlattenChildren ) && g.HoveredWindow && g.HoveredWindow->RootWindow == window;
		if ( flatten_hovered_children )
			g.HoveredWindow = window;

#ifdef IMGUI_ENABLE_TEST_ENGINE
		// Alternate registration spot, for when caller didn't use ItemAdd()
		if ( g.LastItemData.ID != id )
			IMGUI_TEST_ENGINE_ITEM_ADD( id, bb, NULL );
#endif

		ImRect bb;
		ImComputeRect( &bb, pts, pts_count );

		bool pressed = false;
		bool hovered = func( bb, id, pts, pts_count, item_flags );

		// Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
		if ( g.DragDropActive && ( flags & ImGuiButtonFlags_PressedOnDragDropHold ) && !( g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers ) )
			if ( ImGui::IsItemHovered( ImGuiHoveredFlags_AllowWhenBlockedByActiveItem ) )
			{
				hovered = true;
				ImGui::SetHoveredID( id );
				if ( g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER )
				{
					pressed = true;
					g.DragDropHoldJustPressedId = id;
					ImGui::FocusWindow( window );
				}
			}

		if ( flatten_hovered_children )
			g.HoveredWindow = backup_hovered_window;

		// Mouse handling
		const ImGuiID test_owner_id = ( flags & ImGuiButtonFlags_NoTestKeyOwner ) ? ImGuiKeyOwner_Any : id;
		if ( hovered )
		{
			IM_ASSERT( id != 0 ); // Lazily check inside rare path.

			// Poll mouse buttons
			// - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
			// - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
			int mouse_button_clicked = -1;
			int mouse_button_released = -1;
			for ( int button = 0; button < 3; button++ )
				if ( flags & ( ImGuiButtonFlags_MouseButtonLeft << button ) ) // Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
				{
					if ( ImGui::IsMouseClicked( button, ImGuiInputFlags_None, test_owner_id ) && mouse_button_clicked == -1 )
					{
						mouse_button_clicked = button;
					}
					if ( ImGui::IsMouseReleased( button, test_owner_id ) && mouse_button_released == -1 )
					{
						mouse_button_released = button;
					}
				}

			// Process initial action
			if ( !( flags & ImGuiButtonFlags_NoKeyModifiers ) || ( !g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt ) )
			{
				if ( mouse_button_clicked != -1 && g.ActiveId != id )
				{
					if ( !( flags & ImGuiButtonFlags_NoSetKeyOwner ) )
						ImGui::SetKeyOwner( ImGui::MouseButtonToKey( mouse_button_clicked ), id );
					if ( flags & ( ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere ) )
					{
						ImGui::SetActiveID( id, window );
						g.ActiveIdMouseButton = mouse_button_clicked;
						if ( !( flags & ImGuiButtonFlags_NoNavFocus ) )
							ImGui::SetFocusID( id, window );
						ImGui::FocusWindow( window );
					}
					if ( ( flags & ImGuiButtonFlags_PressedOnClick ) || ( ( flags & ImGuiButtonFlags_PressedOnDoubleClick ) && g.IO.MouseClickedCount[ mouse_button_clicked ] == 2 ) )
					{
						pressed = true;
						if ( flags & ImGuiButtonFlags_NoHoldingActiveId )
							ImGui::ClearActiveID();
						else
							ImGui::SetActiveID( id, window ); // Hold on ID
						if ( !( flags & ImGuiButtonFlags_NoNavFocus ) )
							ImGui::SetFocusID( id, window );
						g.ActiveIdMouseButton = mouse_button_clicked;
						ImGui::FocusWindow( window );
					}
				}
				if ( flags & ImGuiButtonFlags_PressedOnRelease )
				{
					if ( mouse_button_released != -1 )
					{
						const bool has_repeated_at_least_once = ( item_flags & ImGuiItemFlags_ButtonRepeat ) && g.IO.MouseDownDurationPrev[ mouse_button_released ] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
						if ( !has_repeated_at_least_once )
							pressed = true;
						if ( !( flags & ImGuiButtonFlags_NoNavFocus ) )
							ImGui::SetFocusID( id, window );
						ImGui::ClearActiveID();
					}
				}

				// 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
				// Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
				if ( g.ActiveId == id && ( item_flags & ImGuiItemFlags_ButtonRepeat ) )
					if ( g.IO.MouseDownDuration[ g.ActiveIdMouseButton ] > 0.0f && ImGui::IsMouseClicked( g.ActiveIdMouseButton, ImGuiInputFlags_Repeat, test_owner_id ) )
						pressed = true;
			}

			if ( pressed )
				g.NavDisableHighlight = true;
		}

		// Gamepad/Keyboard handling
		// We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with mouse.
		if ( g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover )
			if ( !( flags & ImGuiButtonFlags_NoHoveredOnFocus ) )
				hovered = true;
		if ( g.NavActivateDownId == id )
		{
			bool nav_activated_by_code = ( g.NavActivateId == id );
			bool nav_activated_by_inputs = ( g.NavActivatePressedId == id );
			if ( !nav_activated_by_inputs && ( item_flags & ImGuiItemFlags_ButtonRepeat ) )
			{
				// Avoid pressing multiple keys from triggering excessive amount of repeat events
				const ImGuiKeyData* key1 = ImGui::GetKeyData( ImGuiKey_Space );
				const ImGuiKeyData* key2 = ImGui::GetKeyData( ImGuiKey_Enter );
				const ImGuiKeyData* key3 = ImGui::GetKeyData( ImGuiKey_NavGamepadActivate );
				const float t1 = ImMax( ImMax( key1->DownDuration, key2->DownDuration ), key3->DownDuration );
				nav_activated_by_inputs = ImGui::CalcTypematicRepeatAmount( t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate ) > 0;
			}
			if ( nav_activated_by_code || nav_activated_by_inputs )
			{
				// Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
				pressed = true;
				ImGui::SetActiveID( id, window );
				g.ActiveIdSource = g.NavInputSource;
				if ( !( flags & ImGuiButtonFlags_NoNavFocus ) && !( g.NavActivateFlags & ImGuiActivateFlags_FromShortcut ) )
					ImGui::SetFocusID( id, window );
				if ( g.NavActivateFlags & ImGuiActivateFlags_FromShortcut )
					g.ActiveIdFromShortcut = true;
			}
		}

		// Process while held
		bool held = false;
		if ( g.ActiveId == id )
		{
			if ( g.ActiveIdSource == ImGuiInputSource_Mouse )
			{
				if ( g.ActiveIdIsJustActivated )
					g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

				const int mouse_button = g.ActiveIdMouseButton;
				if ( mouse_button == -1 )
				{
					// Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).
					ImGui::ClearActiveID();
				}
				else if ( ImGui::IsMouseDown( mouse_button, test_owner_id ) )
				{
					held = true;
				}
				else
				{
					bool release_in = hovered && ( flags & ImGuiButtonFlags_PressedOnClickRelease ) != 0;
					bool release_anywhere = ( flags & ImGuiButtonFlags_PressedOnClickReleaseAnywhere ) != 0;
					if ( ( release_in || release_anywhere ) && !g.DragDropActive )
					{
						// Report as pressed when releasing the mouse (this is the most common path)
						bool is_double_click_release = ( flags & ImGuiButtonFlags_PressedOnDoubleClick ) && g.IO.MouseReleased[ mouse_button ] && g.IO.MouseClickedLastCount[ mouse_button ] == 2;
						bool is_repeating_already = ( item_flags & ImGuiItemFlags_ButtonRepeat ) && g.IO.MouseDownDurationPrev[ mouse_button ] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
						bool is_button_avail_or_owned = ImGui::TestKeyOwner( ImGui::MouseButtonToKey( mouse_button ), test_owner_id );
						if ( !is_double_click_release && !is_repeating_already && is_button_avail_or_owned )
							pressed = true;
					}
					ImGui::ClearActiveID();
				}
				if ( !( flags & ImGuiButtonFlags_NoNavFocus ) )
					g.NavDisableHighlight = true;
			}
			else if ( g.ActiveIdSource == ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource_Gamepad )
			{
				// When activated using Nav, we hold on the ActiveID until activation button is released
				if ( g.NavActivateDownId == id )
					held = true; // hovered == true not true as we are already likely hovered on direct activation.
				else
					ImGui::ClearActiveID();
			}
			if ( pressed )
				g.ActiveIdHasBeenPressedBefore = true;
		}

		// Activation highlight (this may be a remote activation)
		if ( g.NavHighlightActivatedId == id )
			hovered = true;

		if ( out_hovered ) *out_hovered = hovered;
		if ( out_held ) *out_held = held;

		return pressed;
	}

	bool ButtonBehaviorConvex( ImVec2* pts, int pts_count, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags )
	{
		return ButtonBehaviorShape( pts, pts_count, id, out_hovered, out_held, flags, &ItemHoverablePolyConvex );
	}

	bool ButtonBehaviorConcave( ImVec2* pts, int pts_count, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags )
	{
		return ButtonBehaviorShape( pts, pts_count, id, out_hovered, out_held, flags, &ItemHoverablePolyConcave );
	}

	bool ButtonBehaviorWithHole( ImVec2* pts, int pts_count, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags )
	{
		return ButtonBehaviorShape( pts, pts_count, id, out_hovered, out_held, flags, &ItemHoverablePolyWithHole );
	}

	//////////////////////////////////////////////////////////////////////////
	// Widgets
	//////////////////////////////////////////////////////////////////////////
	bool ButtonExShape( const char* label, const ImVec2& size_arg, ImVec2* pts0, int pts_count, ImVec2 text_offset, ImGuiButtonFlags flags, ImItemHoverablePolyConvexFunc func, ImDrawShape draw_outline, ImDrawShapeFilled draw_fill )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );

		ImVec2 pos = window->DC.CursorPos;
		if ( ( flags & ImGuiButtonFlags_AlignTextBaseLine ) && style.FramePadding.y < window->DC.CurrLineTextBaseOffset ) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
			pos.y += window->DC.CurrLineTextBaseOffset - style.FramePadding.y;
		ImVec2 size = ImGui::CalcItemSize( size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f );

		// Hmm... Lot of copies
		ImVector<ImVec2> points;
		points.resize(pts_count);
		for ( int k = 0; k < pts_count; ++k )
		{
			points[ k ] = pos + pts0[ k ];
		}
		ImVec2* pts = &points[ 0 ];

		ImRect shape_bb;
		ImComputeRect( &shape_bb, pts, pts_count );

		ImRect bb( pos, pos + size );
		bb.Add( shape_bb );
		size.x = ImMax( size.x, bb.GetWidth() );
		size.y = ImMax( size.y, bb.GetHeight() );
		ImGui::ItemSize( size, style.FramePadding.y );
		if ( !ImGui::ItemAdd( bb, id ) )
			return false;

		bool hovered, held;
		bool pressed = ButtonBehaviorShape( pts, pts_count, id, &hovered, &held, flags, func );

		// Render
		const ImU32 col = ImGui::GetColorU32( ( held && hovered ) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button );
		RenderNavHighlightShape( pts, pts_count, id, 0, draw_outline );
		RenderFrameShape( pts, pts_count, col, true, draw_outline, draw_fill );

		if ( g.LogEnabled )
			ImGui::LogSetNextTextDecoration( "[", "]" );
		ImGui::RenderTextClipped( text_offset + bb.Min + style.FramePadding, text_offset + bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb );

		// Automatically close popups
		//if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
		//    CloseCurrentPopup();

		IMGUI_TEST_ENGINE_ITEM_INFO( id, label, g.LastItemData.StatusFlags );
		return pressed;
	}
	bool ButtonExConvex( const char* label, const ImVec2& size_arg, ImVec2* pts, int pts_count, ImGuiButtonFlags flags )
	{
		return ButtonExShape( label, size_arg, pts, pts_count, ImVec2( 0.0f, 0.0f ), flags, &ItemHoverablePolyConvex, &ImDrawShapeConvex, &ImDrawShapeConvexFilled );
	}
	bool ButtonExConcave( const char* label, const ImVec2& size_arg, ImVec2* pts, int pts_count, ImVec2 text_offset, ImGuiButtonFlags flags )
	{
		return ButtonExShape( label, size_arg, pts, pts_count, text_offset, flags, &ItemHoverablePolyConcave, &ImDrawShapeConcave, &ImDrawShapeConcaveFilled );
	}
	bool ButtonExWithHole( const char* label, const ImVec2& size_arg, ImVec2* pts, int pts_count, ImVec2 text_offset, ImGuiButtonFlags flags )
	{
		return ButtonExShape( label, size_arg, pts, pts_count, text_offset, flags, &ItemHoverablePolyWithHole, &ImDrawShapeWithHole, &ImDrawShapeWithHoleFilled );
	}

	ImU32 ImInternalHueMaskingFunc( float const xx, void* pUserData )
	{
		float* values = ( float* )pUserData;
		float hueAlpha = values[ 0 ];
		float centerV = values[ 1 ];
		float widthV = values[ 2 ];
		float left = values[ 3 ];
		float right = values[ 4 ];
		float x = ImFmod( xx, 1.0f );
		float val;
		if ( x < centerV - widthV && x > centerV - widthV - left )
		{
			val = ImClamp( ( centerV * ( -1 + hueAlpha ) + left + widthV + x - hueAlpha * ( widthV + x ) ) / left, hueAlpha, 1.0f );
		}
		else if ( x < centerV + widthV + right && x > centerV + widthV )
		{
			val = ImClamp( ( centerV - centerV * hueAlpha + right + widthV - hueAlpha * widthV + ( -1 + hueAlpha ) * x ) / right, hueAlpha, 1.0f );
		}
		else if ( x > centerV - widthV - left && x < centerV + widthV + right )
		{
			val = 1.0f;
		}
		else if ( centerV + widthV + right > 1.0f )
		{
			val = ImClamp( ( centerV - centerV * hueAlpha + right + widthV - hueAlpha * widthV + ( -1 + hueAlpha ) * ( x + 1.0f ) ) / right, hueAlpha, 1.0f );
		}
		else if ( centerV - widthV - left < 0.0f )
		{
			val = ImClamp( ( centerV * ( -1 + hueAlpha ) + left + widthV + x - 1.0f - hueAlpha * ( widthV + x - 1.0f ) ) / left, hueAlpha, 1.0f );
		}
		else
		{
			val = hueAlpha;
		}
		return IM_COL32( 0, 0, 0, ImPow( 1.0f - val, 1.0f / 2.2f ) * 255 );
	}

	bool HueSelector( char const* label, float hueHeight, float cursorHeight, float* hueCenter, float* hueWidth, float* featherLeft, float* featherRight, int division, float alpha, float hideHueAlpha, float offset )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const float w = ImGui::CalcItemWidth();

		const float cursorSize = cursorHeight;

		ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );
		label_size.y = ImMax( label_size.y, hueHeight );

		const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2.0f ) );
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( cursorSize + ( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f ), cursorSize ) );

		const ImRect hue_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, hueHeight ) );
		const ImRect cursor_bb( ImVec2( hue_bb.Min.x, hue_bb.Max.y ), hue_bb.Max + ImVec2( 0.0f, cursorHeight ) );
		const ImRect full_bb( hue_bb.Min, cursor_bb.Max );

		const ImVec2 curPos = window->DC.CursorPos;

		ImGui::ItemSize( total_bb, style.FramePadding.y );
		if ( !ImGui::ItemAdd( total_bb, id, &frame_bb, 0 ) )
			return false;

		const bool hovered = ImGui::ItemHoverable( full_bb, id, g.LastItemData.InFlags );

		// Tabbing or CTRL-clicking on Slider turns it into an input box
		const bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, id );
		const bool make_active = ( clicked || g.NavActivateId == id );
		if ( make_active && clicked )
			ImGui::SetKeyOwner( ImGuiKey_MouseLeft, id );

		if ( make_active )
		{
			ImGui::SetActiveID( id, window );
			ImGui::SetFocusID( id, window );
			ImGui::FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		}

		// Draw frame
		const ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		ImGui::RenderNavHighlight( full_bb, id );
		ImGui::RenderFrame( full_bb.Min, full_bb.Max, frame_col, true, g.Style.FrameRounding );

		// Slider behavior
		ImRect grab_bb;
		float zero = 0.0f;
		float one = 1.0f;
		const bool value_changed = ImGui::SliderBehavior( full_bb, id, ImGuiDataType_Float, hueCenter, &zero, &one, NULL, ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bb );
		if ( value_changed )
			ImGui::MarkItemEdited( id );

		if ( label_size.x > 0.0f )
			ImGui::RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

		float red[] = { 1.0f, 0.0f, 0.0f };
		DrawHueBand( window->DrawList, hue_bb.Min, hue_bb.GetSize(), division, &red[ 0 ], alpha, offset );

		float center = ImClamp( ImFmod( *hueCenter + offset, 1.0f ), 0.0f, 1.0f - 1e-4f );
		float width = ImClamp( *hueWidth, 0.0f, 0.5f - 1e-4f );
		float featherL = ImClamp( *featherLeft, 0.0f, 0.5f - 1e-4f );
		float featherR = ImClamp( *featherRight, 0.0f, 0.5f - 1e-4f );

		ImWidgets::Style& dwstyle = ImWidgets::GetStyle();

		float xCenter = curPos.x + center * w;
		if ( width == 0.0f )
		{
			// TODO: add style for thickness or color
			window->DrawList->AddLine( ImVec2( xCenter, curPos.y ), ImVec2( xCenter, curPos.y + hueHeight ), IM_COL32( 0, 0, 0, 255 ), dwstyle.HueSelector_Thickness_ZeroWidth );
		}
		else
		{
			float data[] = { hideHueAlpha, center, width, featherL, featherR };
			DrawProceduralColor1DBilinear(  window->DrawList,
										    ImInternalHueMaskingFunc, &data[ 0 ],
										    0.0f, 1.0f, hue_bb.Min, hue_bb.GetSize(), division );
		}

		// Render grab
		float pos = ImLerp( cursor_bb.Min.x, cursor_bb.Max.x, *hueCenter );
		DrawTriangleCursorFilled( window->DrawList, ImVec2( pos, cursor_bb.Min.y ), 0.0f, cursorSize, IM_COL32( 255, 255, 255, 255 ) );

		return value_changed;
	}

	bool SliderNScalar( char const* label, ImGuiDataType data_type, void* ordered_value, int value_count, void* p_min, void* p_max, float cursor_width, bool show_hover_by_region )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		IM_ASSERT( value_count > 1 );

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const float w = ImGui::CalcItemWidth();

		ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );

		const ImRect frame_bb( window->DC.CursorPos + ImVec2(cursor_width , 0.0f), window->DC.CursorPos + ImVec2(w - cursor_width, label_size.y + style.FramePadding.y * 2.0f));
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( ( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f ), 0.0f ) );

		const ImVec2 curPos = window->DC.CursorPos;

		float fMin = ScalarToFloat( data_type, ( ImU64* )p_min );
		float fMax = ScalarToFloat( data_type, ( ImU64* )p_max );

		ImVector<ImGuiID> ids;
		ids.resize( value_count );
		ids[ 0 ] = window->GetID( id );
		for ( int k = 1; k < value_count; ++k )
		{
			ids[ k ] = window->GetID( ids[ k - 1 ] );
		}

		ImVector<float> centers;
		centers.resize(value_count + 1);
		centers[ 0 ] = Rescale01( fMin, fMin, fMax );
		for ( int k = 1; k < value_count; ++k )
		{
			float x0 = ScalarIndirectToFloat( data_type, ordered_value, k - 1 );
			float x1 = ScalarIndirectToFloat( data_type, ordered_value, k );
			centers[ k ] = Rescale01( x0 * 0.5f + x1 * 0.5f, fMin, fMax );
		}
		centers[ value_count ] = Rescale01( fMax, fMin, fMax );

		ImVector< ImRect > drag_bbs;
		drag_bbs.resize( value_count );
		for ( int k = 1; k <= value_count; ++k )
		{
			drag_bbs[ k - 1 ] = ImRect( 
					ImVec2( ImLerp( frame_bb.Min.x, frame_bb.Max.x, centers[ k - 1 ] ), frame_bb.Min.y ),
					ImVec2( ImLerp( frame_bb.Min.x, frame_bb.Max.x, centers[ k     ] ), frame_bb.Max.y )
				);
		}
		//srand( 97 );
		//for ( int k = 0; k < value_count; ++k )
		//{
		//	ImRect& bb = drag_bbs[ k ];
		//	window->DrawList->AddRect( bb.Min, bb.Max, IM_COL32( rand() % 255, rand() % 255, rand() % 255, 255 ), 0, 0, 5 );
		//}
		//srand( 97 );
		//for ( int k = 0; k < value_count; ++k )
		//{
		//	float x = ImLerp( frame_bb.Min.x, frame_bb.Max.x, ScalarIndirectToFloat( data_type, ordered_value, k ) / ( ScalarToFloat( data_type, ( ImU64* )p_max ) - ScalarToFloat( data_type, ( ImU64* )p_min ) ) );
		//	window->DrawList->AddLine( ImVec2( x, frame_bb.Min.y ), ImVec2( x, frame_bb.Max.y ), IM_COL32( rand() % 255, rand() % 255, rand() % 255, 255 ), 5 );
		//}

		ImGui::ItemSize( total_bb, style.FramePadding.y );

		// Slider behavior
		ImRect grab_bb;
		float zero = 0.0f;
		float one = 1.0f;
		bool value_changed = false;
		bool full_hovered = false;
		bool is_active = false;
		for ( int k = 0; k < value_count; ++k )
		{
			ImRect& bb = drag_bbs[ k ];

			if ( !ImGui::ItemAdd( total_bb, ids[ k ], &bb, 0) )
				return false;

			const bool hovered = ImGui::ItemHoverable( bb, ids[ k ], g.LastItemData.InFlags );
			full_hovered |= hovered;

			// Tabbing or CTRL-clicking on Slider turns it into an input box
			const bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, ids[ k ] );
			const bool make_active = ( clicked || g.NavActivateId == ids[ k ] );
			if ( make_active && clicked )
				ImGui::SetKeyOwner( ImGuiKey_MouseLeft, ids[ k ] );

			if ( make_active )
			{
				ImGui::SetActiveID( ids[ k ], window );
				ImGui::SetFocusID( ids[ k ], window );
				ImGui::FocusWindow( window );
				g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
			}

			is_active |= ( g.ActiveId == ids[ k ] );
			if ( show_hover_by_region )
			{
				// Draw frame
				const ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == ids[ k ] ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
				ImGui::RenderNavHighlight( bb, ids[ k ] );
				ImGui::RenderFrame( bb.Min, bb.Max, frame_col, true, g.Style.FrameRounding );
			}

			ImU64 currentValue = ScalarIndirectToScalar( data_type, ordered_value, k );
			float local_min = bb.Min.x;
			float local_max = bb.Max.x;
			local_min = Rescale(local_min, frame_bb.Min.x, frame_bb.Max.x, fMin, fMax);
			local_max = Rescale(local_max, frame_bb.Min.x, frame_bb.Max.x, fMin, fMax);
			ImU64 v_local_min = FloatToScalar( data_type, local_min );
			ImU64 v_local_max = FloatToScalar( data_type, local_max );
			float signet01;
			if ( k == 0 )
				signet01 = 0.0f;
			else if ( k == value_count - 1 )
				signet01 = 1.0f;
			else
				signet01 = 0.5f;
			float x = ImLerp( frame_bb.Min.x, frame_bb.Max.x, ScalarIndirectToFloat( data_type, ordered_value, k ) / ( ScalarToFloat( data_type, ( ImU64* )p_max ) - ScalarToFloat( data_type, ( ImU64* )p_min ) ) );
			DrawSignetFilledCursor( window->DrawList, ImVec2( x, frame_bb.Min.y ), cursor_width, frame_bb.GetHeight(), 1.0f / 3.0f, signet01, 0.0f, IM_COL32( 255, 0, 0, 255 ) );
			bool current_value_changed = ImGui::SliderBehavior( bb, ids[ k ], ImGuiDataType_Float, &currentValue, &v_local_min, &v_local_max, NULL, ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bb);
			if ( current_value_changed )
			{
				SetScalarIndirect( data_type, ordered_value, k, &currentValue );
				ImGui::MarkItemEdited( ids[ k ] );
			}
			value_changed |= current_value_changed;
		}
		if ( !show_hover_by_region )
		{
			const ImU32 frame_col = ImGui::GetColorU32( is_active ? ImGuiCol_FrameBgActive : full_hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
			ImGui::RenderNavHighlight( frame_bb, id );
			ImGui::RenderFrame( frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding );
		}
		for ( int k = 0; k < value_count; ++k )
		{
			ImRect& bb = drag_bbs[ k ];

			float signet01;
			if ( k == 0 )
				signet01 = 0.0f;
			else if ( k == value_count - 1 )
				signet01 = 1.0f;
			else
				signet01 = 0.5f;
			float x = ImLerp( frame_bb.Min.x, frame_bb.Max.x, ScalarIndirectToFloat( data_type, ordered_value, k ) / ( ScalarToFloat( data_type, ( ImU64* )p_max ) - ScalarToFloat( data_type, ( ImU64* )p_min ) ) );
			DrawSignetFilledCursor( window->DrawList, ImVec2( x, frame_bb.Min.y ), cursor_width, frame_bb.GetHeight(), 1.0f / 3.0f, signet01, 0.0f, IM_COL32( 255, 0, 0, 255 ) );
		}

		if ( label_size.x > 0.0f )
			ImGui::RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x + cursor_width, frame_bb.Min.y + style.FramePadding.y ), label );

		return false;
	}

	bool SliderNFloat( char const* label, ImGuiDataType data_type, float* ordered_value, int value_count, float v_min, float v_max, float cursor_width, bool show_hover_by_region )
	{
		return SliderNScalar( label, ImGuiDataType_Float, ordered_value, value_count, &v_min, &v_max, cursor_width, show_hover_by_region );
	}

	bool SliderNInt( char const* label, ImGuiDataType data_type, int* ordered_value, int value_count, int v_min, int v_max, float cursor_width, bool show_hover_by_region )
	{
		return SliderNScalar( label, ImGuiDataType_S32, ordered_value, value_count, &v_min, &v_max, cursor_width, show_hover_by_region );
	}

	// TODO: Add bool flipY
	bool Slider2DScalar( char const* label, ImGuiDataType data_type, void* p_valueX, void* p_valueY, void* p_minX, void* p_maxX, void* p_minY, void* p_maxY )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		IM_ASSERT( ScalarToFloat( data_type, ( ImU64* )p_minX ) < ScalarToFloat( data_type, ( ImU64* )p_maxX ) );
		IM_ASSERT( ScalarToFloat( data_type, ( ImU64* )p_minY ) < ScalarToFloat( data_type, ( ImU64* )p_maxY ) );

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		ImGuiID idX = window->GetID( id );
		ImGuiID idY = window->GetID( idX );
		const float w = ImGui::CalcItemWidth();

		ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );

		// TODO: Move those to style
		float downScale = 0.75f;
		float dragX_placement = 0.75f;
		float dragY_placement = 0.75f;
		float dragX_thickness = 8.0f;
		float dragY_thickness = 8.0f;
		float border_thickness = 2.0f;
		float line_thickness = 2.0f;
		float text_lerp_x = 0.5f;
		float text_lerp_y = 0.5f;
		float cursor_radius = 4.0f;
		int cursor_segments = 4;
		//ImVec4 vBlue( 70.0f / 255.0f, 102.0f / 255.0f, 230.0f / 255.0f, 1.0f ); // TODO: choose from style
		ImVec4 vBlue( 91.0f / 255.0f, 194.0f / 255.0f, 231.0f / 255.0f, 1.0f ); // TODO: choose from style
		ImVec4 vOrange( 255.0f / 255.0f, 128.0f / 255.0f, 64.0f / 255.0f, 1.0f ); // TODO: choose from style
		ImU32 uBlue = ImGui::GetColorU32( vBlue );
		ImU32 uOrange = ImGui::GetColorU32( vOrange );
		float fCursorOff = 16.0f;

		const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, w ) );
		const ImRect frame_bb_drag( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w * downScale, w * downScale ) );
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );
		const ImRect frame_bb_dragX( ImVec2( frame_bb_drag.Min.x, ImLerp( frame_bb_drag.Max.y, frame_bb.Max.y, dragX_placement ) ),
									 ImVec2( frame_bb_drag.Max.x, ImLerp( frame_bb_drag.Max.y, frame_bb.Max.y, dragX_placement ) + dragX_thickness ) );
		const ImRect frame_bb_dragY( ImVec2( ImLerp( frame_bb_drag.Max.x, frame_bb.Max.x, dragY_placement ), frame_bb_drag.Min.y ),
									 ImVec2( ImLerp( frame_bb_drag.Max.x, frame_bb.Max.x, dragY_placement ) + dragY_thickness, frame_bb_drag.Max.y ) );

		float fXLimit = fCursorOff / frame_bb_drag.GetWidth();
		float fYLimit = fCursorOff / frame_bb_drag.GetHeight();

		const ImVec2 curPos = window->DC.CursorPos;

		ImGui::ItemSize( total_bb, style.FramePadding.y );
		if ( !ImGui::ItemAdd( total_bb, id, &frame_bb, 0 ) )
			return false;

		bool hovered = ImGui::ItemHoverable( frame_bb_drag, id, g.LastItemData.InFlags );

		bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, id );
		bool make_active = ( clicked || g.NavActivateId == id );
		if ( make_active && clicked )
			ImGui::SetKeyOwner( ImGuiKey_MouseLeft, id );

		if ( make_active )
		{
			ImGui::SetActiveID( id, window );
			ImGui::SetFocusID( id, window );
			ImGui::FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		}

		// Draw frame
		ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		ImGui::RenderNavHighlight( frame_bb_drag, id );
		ImGui::RenderFrame( frame_bb_drag.Min, frame_bb_drag.Max, frame_col, true, g.Style.FrameRounding );

		// Slider behavior
		ImRect grab_bbX;
		ImRect grab_bbY;
		float zero = 0.0f;
		float one = 1.0f;
		bool value_changedX = ImGui::SliderBehavior( frame_bb_drag, id, data_type, p_valueX, p_minX, p_maxX, NULL, ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bbX );
		bool value_changedY = ImGui::SliderBehavior( frame_bb_drag, id, data_type, p_valueY, p_minY, p_maxY, NULL, ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat | ImGuiSliderFlags_Vertical, &grab_bbY );
		if ( value_changedX || value_changedY )
			ImGui::MarkItemEdited( id );

		if ( !ImGui::ItemAdd( total_bb, idX, &frame_bb_dragX, 0 ) )
			return false;

		hovered = ImGui::ItemHoverable( frame_bb_dragX, idX, g.LastItemData.InFlags );

		clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, idX );
		make_active = ( clicked || g.NavActivateId == idX );
		if ( make_active && clicked )
			ImGui::SetKeyOwner( ImGuiKey_MouseLeft, idX );

		if ( make_active )
		{
			ImGui::SetActiveID( idX, window );
			ImGui::SetFocusID( idX, window );
			ImGui::FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		}
		frame_col = ImGui::GetColorU32( g.ActiveId == idX ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		bool value_changedXS = ImGui::SliderBehavior( frame_bb_dragX, idX, data_type, p_valueX, p_minX, p_maxX, NULL, ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat, &grab_bbX );
		if ( value_changedX )
			ImGui::MarkItemEdited( idX );

		ImGui::RenderNavHighlight( frame_bb_dragX, idX );
		ImGui::RenderFrame( frame_bb_dragX.Min, frame_bb_dragX.Max, frame_col, true, g.Style.FrameRounding );

		if ( !ImGui::ItemAdd( total_bb, idY, &frame_bb_dragX, 0 ) )
			return false;

		hovered = ImGui::ItemHoverable( frame_bb_dragY, idY, g.LastItemData.InFlags );

		clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, idY );
		make_active = ( clicked || g.NavActivateId == idY );
		if ( make_active && clicked )
			ImGui::SetKeyOwner( ImGuiKey_MouseLeft, idY );

		if ( make_active )
		{
			ImGui::SetActiveID( idY, window );
			ImGui::SetFocusID( idY, window );
			ImGui::FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		}
		frame_col = ImGui::GetColorU32( g.ActiveId == idY ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );

		ImGui::RenderNavHighlight( frame_bb_dragY, idY );
		ImGui::RenderFrame( frame_bb_dragY.Min, frame_bb_dragY.Max, frame_col, true, g.Style.FrameRounding );

		bool value_changedYS = ImGui::SliderBehavior( frame_bb_dragY, idY, data_type, p_valueY, p_minY, p_maxY, NULL, ImGuiSliderFlags_NoInput | ImGuiSliderFlags_NoRoundToFormat | ImGuiSliderFlags_Vertical, &grab_bbY );

		if ( label_size.x > 0.0f )
			ImGui::RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

		ImDrawList* pDrawList = window->DrawList;

		ImU64 s_delta_x = SubScalar( data_type, p_maxX, p_minX );
		ImU64 s_delta_y = SubScalar( data_type, p_maxY, p_minY );
		float fScaleX = ( ScalarToFloat( data_type, ( ImU64* )p_valueX ) - ScalarToFloat( data_type, ( ImU64* )p_minX ) ) / ScalarToFloat( data_type, &s_delta_x );
		float fScaleY = 1.0 - ( ScalarToFloat( data_type, ( ImU64* )p_valueY ) - ScalarToFloat( data_type, ( ImU64* )p_minY ) ) / ScalarToFloat( data_type, &s_delta_y );
		ImVec2 vCursorPos( ( frame_bb_drag.Max.x - frame_bb_drag.Min.x ) * fScaleX + frame_bb_drag.Min.x, ( frame_bb_drag.Max.y - frame_bb_drag.Min.y ) * fScaleY + frame_bb_drag.Min.y );

		char const* formatX = ImGui::DataTypeGetInfo( data_type )->PrintFmt;
		char const* formatY = ImGui::DataTypeGetInfo( data_type )->PrintFmt;

		//if ( IsPositiveScalar( data_type, ( ImU64* )p_valueX ) )
		//{
		//	formatX = " " + formatX;
		//}
		//if ( IsPositiveScalar( data_type, ( ImU64* )p_valueY ) )
		//{
		//	formatY = " " + formatY;
		//}

		// Cursor
		pDrawList->AddCircleFilled( vCursorPos, cursor_radius, uBlue, cursor_segments );

		// Vertical Line
		if ( fScaleY > 2.0f * fYLimit )
			pDrawList->AddLine( ImVec2( vCursorPos.x, frame_bb_drag.Min.y + fCursorOff ), ImVec2( vCursorPos.x, vCursorPos.y - fCursorOff ), uOrange, line_thickness );
		if ( fScaleY < 1.0f - 2.0f * fYLimit )
			pDrawList->AddLine( ImVec2( vCursorPos.x, frame_bb_drag.Max.y - fCursorOff ), ImVec2( vCursorPos.x, vCursorPos.y + fCursorOff ), uOrange, line_thickness );

		// Horizontal Line
		if ( fScaleX > 2.0f * fXLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Min.x + fCursorOff, vCursorPos.y ), ImVec2( vCursorPos.x - fCursorOff, vCursorPos.y ), uOrange, line_thickness );
		if ( fScaleX < 1.0f - 2.0f * fYLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Max.x - fCursorOff, vCursorPos.y ), ImVec2( vCursorPos.x + fCursorOff, vCursorPos.y ), uOrange, line_thickness );

		// Borders::Right
		pDrawList->AddCircleFilled( ImVec2( frame_bb_drag.Max.x, vCursorPos.y ), 2.0f, uOrange, 3 );
		// Handle Right::Y
		pDrawList->AddNgonFilled( ImVec2( frame_bb_dragY.GetCenter().x, vCursorPos.y ), dragY_thickness * 0.5f, uOrange, 4 );
		if ( fScaleY > fYLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Max.x, frame_bb_drag.Min.y ), ImVec2( frame_bb_drag.Max.x, vCursorPos.y - fCursorOff ), uBlue, border_thickness );
		if ( fScaleY < 1.0f - fYLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Max.x, frame_bb_drag.Max.y ), ImVec2( frame_bb_drag.Max.x, vCursorPos.y + fCursorOff ), uBlue, border_thickness );
		// Borders::Top
		pDrawList->AddCircleFilled( ImVec2( vCursorPos.x, frame_bb_drag.Min.y ), 2.0f, uOrange, 3 );
		if ( fScaleX > fXLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Min.x, frame_bb_drag.Min.y ), ImVec2( vCursorPos.x - fCursorOff, frame_bb_drag.Min.y ), uBlue, border_thickness );
		if ( fScaleX < 1.0f - fXLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Max.x, frame_bb_drag.Min.y ), ImVec2( vCursorPos.x + fCursorOff, frame_bb_drag.Min.y ), uBlue, border_thickness );
		// Borders::Left
		pDrawList->AddCircleFilled( ImVec2( frame_bb_drag.Min.x, vCursorPos.y ), 2.0f, uOrange, 3 );
		if ( fScaleY > fYLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Min.x, frame_bb_drag.Min.y ), ImVec2( frame_bb_drag.Min.x, vCursorPos.y - fCursorOff ), uBlue, border_thickness );
		if ( fScaleY < 1.0f - fYLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Min.x, frame_bb_drag.Max.y ), ImVec2( frame_bb_drag.Min.x, vCursorPos.y + fCursorOff ), uBlue, border_thickness );
		// Borders::Bottom
		pDrawList->AddCircleFilled( ImVec2( vCursorPos.x, frame_bb_drag.Max.y ), 2.0f, uOrange, 3 );
		// Handle Bottom::X
		pDrawList->AddNgonFilled( ImVec2( vCursorPos.x, frame_bb_dragX.GetCenter().y ), dragX_thickness * 0.5f, uOrange, 4 );
		if ( fScaleX > fXLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Min.x, frame_bb_drag.Max.y ), ImVec2( vCursorPos.x - fCursorOff, frame_bb_drag.Max.y ), uBlue, border_thickness );
		if ( fScaleX < 1.0f - fXLimit )
			pDrawList->AddLine( ImVec2( frame_bb_drag.Max.x, frame_bb_drag.Max.y ), ImVec2( vCursorPos.x + fCursorOff, frame_bb_drag.Max.y ), uBlue, border_thickness );

		// Add Text
		char pBufferX[ 64 ];
		char pBufferY[ 64 ];
		ImGui::DataTypeFormatString( pBufferX, IM_ARRAYSIZE( pBufferX ), data_type, p_valueX, formatX );
		ImGui::DataTypeFormatString( pBufferY, IM_ARRAYSIZE( pBufferY ), data_type, p_valueY, formatY );

		ImU32 const uTextCol = ImGui::ColorConvertFloat4ToU32( ImGui::GetStyle().Colors[ ImGuiCol_Text ] );

		ImGui::SetWindowFontScale( 0.75f );

		ImVec2 const vXSize = ImGui::CalcTextSize( pBufferX );
		ImVec2 const vYSize = ImGui::CalcTextSize( pBufferY );

		pDrawList->AddText(
			ImVec2(
				ImClamp( vCursorPos.x - vXSize.x * 0.5f, frame_bb_drag.Min.x, frame_bb_drag.Min.x + frame_bb_drag.GetWidth() - vXSize.x ),
				ImLerp( frame_bb_drag.Max.y, frame_bb_dragX.Min.y - vXSize.y, text_lerp_x ) ),
			uTextCol,
			pBufferX );
		pDrawList->AddText(
			ImVec2( ImLerp( frame_bb_drag.Max.x, frame_bb_dragY.Min.x - vYSize.x, text_lerp_y ),
					ImClamp( vCursorPos.y - vXSize.y * 0.5f, frame_bb_drag.Min.y, frame_bb_drag.Min.y + frame_bb_drag.GetHeight() - vYSize.y ) ),
			uTextCol,
			pBufferY );

		ImGui::SetWindowFontScale( 1.0f );

		return value_changedX || value_changedY || value_changedXS || value_changedYS;
	}

	bool Slider2DFloat( char const* pLabel, float* pValueX, float* pValueY, float v_minX, float v_maxX, float v_minY, float v_maxY )
	{
		return Slider2DScalar( pLabel, ImGuiDataType_Float, pValueX, pValueY, &v_minX, &v_maxX, &v_minY, &v_maxY );
	}

	bool Slider2DInt( char const* pLabel, int* pValueX, void* pValueY, int v_minX, int v_maxX, int v_minY, int v_maxY )
	{
		return Slider2DScalar( pLabel, ImGuiDataType_S32, pValueX, pValueY, &v_minX, &v_maxX, &v_minY, &v_maxY );
	}

	// TODO
	bool SliderRingScalar( char const* label, ImGuiDataType data_type, void* p_value, void* p_min, void* p_max, float v_angle_min, float v_angle_max, float v_thickness, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb )
	{

		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		IM_ASSERT( ScalarToFloat( data_type, ( ImU64* )p_min ) < ScalarToFloat( data_type, ( ImU64* )p_max ) );

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const float w = ImGui::CalcItemWidth();

		ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );

		float downScale = 0.75f;

		const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, w ) );
		const ImRect frame_bb_drag( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w * downScale, w * downScale ) );
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

		ImGui::ItemSize( total_bb, style.FramePadding.y );
		if ( !ImGui::ItemAdd( total_bb, id, &frame_bb, 0 ) )
			return false;

		bool hovered = ImGui::ItemHoverable( frame_bb_drag, id, g.LastItemData.InFlags );

		bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, id );

		bool make_active = ( clicked || g.NavActivateId == id );
		if ( make_active && clicked )
			ImGui::SetKeyOwner( ImGuiKey_MouseLeft, id );

		if ( make_active )
		{
			ImGui::SetActiveID( id, window );
			ImGui::SetFocusID( id, window );
			ImGui::FocusWindow( window );
			g.ActiveIdUsingNavDirMask |= ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
		}

		// Draw frame
		ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		ImGui::RenderNavHighlight( frame_bb_drag, id );
		ImGui::RenderFrame( frame_bb_drag.Min, frame_bb_drag.Max, frame_col, true, g.Style.FrameRounding );

		return false;
	}

#if 0
	bool DragFloatPrecise( char const* label, float* value, float v_min, float v_max, ImGuiSliderFlags flags )
	{
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		if ( window->SkipItems )
			return false;

		ImGuiContext& g = *GImGui;
		const ImGuiStyle& style = g.Style;
		const ImGuiID id = window->GetID( label );
		const ImGuiID idP = window->GetID( id );
		const float w = ImGui::CalcItemWidth();

		const ImVec2 label_size = ImGui::CalcTextSize( label, NULL, true );
		const ImRect frame_bb( window->DC.CursorPos, window->DC.CursorPos + ImVec2( w, label_size.y + style.FramePadding.y * 2.0f ) );
		const ImRect total_bb( frame_bb.Min, frame_bb.Max + ImVec2( label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f ) );

		float precision_block_size = 128.0f;

		const bool temp_input_allowed = ( flags & ImGuiSliderFlags_NoInput ) == 0;
		ImGui::ItemSize( total_bb, style.FramePadding.y );
		if ( !ImGui::ItemAdd( total_bb, id, &frame_bb, temp_input_allowed ? ImGuiItemFlags_Inputable : 0 ) )
			return false;

		// Default format string when passing NULL
		const bool hovered = ImGui::ItemHoverable( frame_bb, id, g.LastItemData.InFlags );
		bool temp_input_is_active = temp_input_allowed && ImGui::TempInputIsActive( id );
		if ( !temp_input_is_active )
		{
			// Tabbing or CTRL-clicking on Drag turns it into an InputText
			const bool clicked = hovered && ImGui::IsMouseClicked( 0, ImGuiInputFlags_None, id );
			const bool double_clicked = ( hovered && g.IO.MouseClickedCount[ 0 ] == 2 && ImGui::TestKeyOwner( ImGuiKey_MouseLeft, id ) );
			const bool make_active = ( clicked || double_clicked || g.NavActivateId == id );
			if ( make_active && ( clicked || double_clicked ) )
				ImGui::SetKeyOwner( ImGuiKey_MouseLeft, id );
			if ( make_active && temp_input_allowed )
				if ( ( clicked && g.IO.KeyCtrl ) || double_clicked || ( g.NavActivateId == id && ( g.NavActivateFlags & ImGuiActivateFlags_PreferInput ) ) )
					temp_input_is_active = true;

			// (Optional) simple click (without moving) turns Drag into an InputText
			if ( g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active )
				if ( g.ActiveId == id && hovered && g.IO.MouseReleased[ 0 ] && !ImGui::IsMouseDragPastThreshold( 0, g.IO.MouseDragThreshold * ImGui::GetIO().MouseDragThreshold ) )
				{
					g.NavActivateId = id;
					g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
					temp_input_is_active = true;
				}

			if ( make_active && !temp_input_is_active )
			{
				ImGui::SetActiveID( id, window );
				ImGui::SetFocusID( id, window );
				ImGui::FocusWindow( window );
				g.ActiveIdUsingNavDirMask = ( 1 << ImGuiDir_Left ) | ( 1 << ImGuiDir_Right );
			}
		}

		//float fLog = ImMax< float >( ImRound( ImAbs( ImLog( ImAbs( ImFract( *value ) ) )/ImLog( 10.0f ) ) ), 5.0f );
		//float fLog;
		//float fract = ImAbs( ImFract( *value ) );
		//if ( *value < 1.0f && fract > 0.0f )
		//	fLog = ImMax( ImAbs( ImLog( fract ) / ImLog( 10.0f ) ), 1.0f );
		//else
		//if ( *value != 0 )
		//	fLog = ImRound( ImLog( ImAbs( *value ) ) / ImLog( 10.0f ) );
		//else
		//	fLog = 1.0f;

		//int log = ( int )fLog;
		//std::string sFormat( 16, '\0' );
		//ImFormatString( &sFormat[ 0 ], 16, "%%.%df", log );

		if ( temp_input_is_active )
		{
			// Only clamp CTRL+Click input when ImGuiSliderFlags_AlwaysClamp is set
			const bool is_clamp_input = ( flags & ImGuiSliderFlags_AlwaysClamp ) != 0 && ( ImGui::DataTypeCompare( ImGuiDataType_Float, &v_min, &v_max ) < 0 );
			//return ImGui::TempInputScalar( frame_bb, id, label, ImGuiDataType_Float, value, sFormat.c_str(), is_clamp_input ? &v_min : NULL, is_clamp_input ? &v_max : NULL );
			return ImGui::TempInputScalar( frame_bb, id, label, ImGuiDataType_Float, value, "%.7f", is_clamp_input ? &v_min : NULL, is_clamp_input ? &v_max : NULL);
		}

		float fLog;
		if ( ImGui::IsItemActive() )
		{
			float precision_block_size_half = precision_block_size * 0.5f;
			ImVec2 bb_center = frame_bb.GetCenter();
			const ImRect drag_top_bb( ImVec2( bb_center.x - precision_block_size_half, frame_bb.Min.y - precision_block_size ),
									  ImVec2( bb_center.x + precision_block_size_half, frame_bb.Min.y ) );
			const ImRect drag_bottom_bb( ImVec2( bb_center.x - precision_block_size_half, frame_bb.Max.y ),
										 ImVec2( bb_center.x + precision_block_size_half, frame_bb.Max.y + precision_block_size ) );
			window->DrawList->AddRect( drag_top_bb.Min, drag_top_bb.Max, IM_COL32( 255, 0, 0, 255 ) );
			window->DrawList->AddRect( drag_bottom_bb.Min, drag_bottom_bb.Max, IM_COL32( 0, 255, 0, 255 ) );
			ImGui::ItemAdd( drag_top_bb, idP, NULL, ImGuiItemFlags_AllowOverlap );
			if ( ImGui::IsItemHovered() )
			{
				fLog = 10.0f;
			}
			ImGui::ItemAdd( drag_bottom_bb, idP, NULL, ImGuiItemFlags_AllowOverlap );
			if ( ImGui::IsItemHovered() )
			{
				fLog = 0.01f;
			}
		}

		// Draw frame
		const ImU32 frame_col = ImGui::GetColorU32( g.ActiveId == id ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg );
		ImGui::RenderNavHighlight( frame_bb, id );
		ImGui::RenderFrame( frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding );

		// Drag behavior
		//const bool value_changed = ImGui::DragBehavior( id, ImGuiDataType_Float, value, fLog, &v_min, &v_max, sFormat.c_str(), 0);
		const bool value_changed = ImGui::DragBehavior( id, ImGuiDataType_Float, value, fLog, &v_min, &v_max, "%.7f", 0 );
		if ( value_changed )
			ImGui::MarkItemEdited( id );

		// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
		char value_buf[ 64 ];
		const char* value_buf_end = value_buf + ImGui::DataTypeFormatString( value_buf, IM_ARRAYSIZE( value_buf ), ImGuiDataType_Float, value, "%.7f" );
		if ( g.LogEnabled )
			ImGui::LogSetNextTextDecoration( "{", "}" );
		ImGui::RenderTextClipped( frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2( 0.5f, 0.5f ) );

		if ( label_size.x > 0.0f )
			ImGui::RenderText( ImVec2( frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y ), label );

		return value_changed;
	}
#endif

	//////////////////////////////////////////////////////////////////////////
	// Window Customization
	//////////////////////////////////////////////////////////////////////////
	void SetCurrentWindowBackgroundImage( ImTextureID id, ImVec2 imgSize, bool fixedSize, ImU32 col )
	{
		float ar = imgSize.x / imgSize.y;
		ImGuiWindow* window = ImGui::GetCurrentWindow();
		ImDrawList* drawList = ImGui::GetBackgroundDrawList();
		ImVec2 cur = window->InnerRect.Min;
		ImVec2 uv;
		ImVec2 winSize = ImGui::GetWindowSize();

		if ( fixedSize )
		{
			uv.x = winSize.x / imgSize.x;
			uv.y = winSize.y / imgSize.y;
		}
		else
		{
			if ( winSize.x > winSize.y )
			{
				if ( imgSize.x > imgSize.y )
				{
					uv.x = 1.0f;
					uv.y = winSize.y / winSize.x;
				}
				else
				{
					uv.x = winSize.y / winSize.x;
					uv.y = 1.0f;
				}
			}
			else
			{
				if ( imgSize.x > imgSize.y )
				{
					uv.x = winSize.x / winSize.y;
					uv.y = 1.0f;
				}
				else
				{
					uv.x = 1.0f;
					uv.y = winSize.y / winSize.x;
				}
			}
		}

		drawList->AddImageRounded( id, cur, cur + winSize, ImVec2( 0.0f, 0.0f ), uv, col, window->WindowRounding );
	}
}
